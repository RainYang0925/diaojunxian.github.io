<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>自动化测试</title>
  <subtitle>不二家的小球童的测试之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-01-21T03:42:06.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>diaojunxian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>持续集成(十八)——Samba搭建</title>
    <link href="http://yoursite.com/2017/01/21/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90-%E5%8D%81%E5%85%AB-%E2%80%94%E2%80%94Samba%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2017/01/21/持续集成-十八-——Samba搭建/</id>
    <published>2017-01-21T03:17:49.000Z</published>
    <updated>2017-01-21T03:42:06.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>起因是需要让产品在Axure生成的产品文档方便在内部共享，之前有很多的思路，最后还是走了最简单的一条路。在Linux上搭建一个Samba服务，让产品方便上传文档，开发查看通过自己写的Flask服务。</p>
<h3 id="安装Samba"><a href="#安装Samba" class="headerlink" title="安装Samba"></a>安装Samba</h3><h4 id="1、安装"><a href="#1、安装" class="headerlink" title="1、安装"></a>1、安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install samba</div></pre></td></tr></table></figure>
<h4 id="2、创建共享目录"><a href="#2、创建共享目录" class="headerlink" title="2、创建共享目录"></a>2、创建共享目录</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo mkdir /var/share</div><div class="line">sudo chmod 777 /var/share</div></pre></td></tr></table></figure>
<h4 id="3、修改Samba配置"><a href="#3、修改Samba配置" class="headerlink" title="3、修改Samba配置"></a>3、修改Samba配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo vim /etc/samba/smb.conf</div></pre></td></tr></table></figure>
<p>在配置文件最后加上</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[share]</div><div class="line">   path = /var/share</div><div class="line">   browseable = yes</div><div class="line">   writable = yes</div><div class="line">   public = no</div><div class="line">   writable = yes</div></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：public的设置是确认用户是否需要输入密码</p>
</blockquote>
<p>设定<code>public=no</code>时候，设定访问用户：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo adduser test</div><div class="line">sudo smbpasswd -a test</div></pre></td></tr></table></figure>
<h4 id="4、启动Samba"><a href="#4、启动Samba" class="headerlink" title="4、启动Samba"></a>4、启动Samba</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"># 启动</div><div class="line">sudo /etc/init.d/smbd start</div><div class="line"># 重启</div><div class="line">sudo /etc/init.d/smbd restart</div><div class="line"># 关闭</div><div class="line">sudo /etc/init.d/smbd shutdown</div></pre></td></tr></table></figure>
<h4 id="5、访问"><a href="#5、访问" class="headerlink" title="5、访问"></a>5、访问</h4><p>Win环境访问：在我的电脑中选择映射网络浏览器，然后输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\\192.168.1.100\share</div></pre></td></tr></table></figure>
<p>Mac环境访问：在<code>Finder</code>中选择菜单上的<code>前往</code>，然后选择<code>连接服务器</code>，然后输入，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">smb://192.168.1.100/share</div></pre></td></tr></table></figure>
<h3 id="开发查看产品文档"><a href="#开发查看产品文档" class="headerlink" title="开发查看产品文档"></a>开发查看产品文档</h3><p>我是通过Flask写了一个服务，然后将地址映射到共享的目录，注意到<code>Axure</code>生成的<code>html</code>文件夹都存在一个<code>index.html</code>，然后点击<code>index.html</code>就可以直接查看整个文档。<br>具体代码实现为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line">from __future__ import division</div><div class="line">from flask import request, session, g, send_file, url_for, abort, render_template, flash, jsonify, make_response, Response, redirect</div><div class="line">from werkzeug.utils import secure_filename</div><div class="line">from werkzeug.exceptions import NotFound</div><div class="line">from flask import Flask, request, make_response, send_file, safe_join, redirect, Response</div><div class="line">import sys, os, cgi, urllib, posixpath, argparse</div><div class="line">from StringIO import StringIO</div><div class="line">from pypinyin import lazy_pinyin</div><div class="line">import commands</div><div class="line">import json</div><div class="line"></div><div class="line"></div><div class="line">def init_router(app):</div><div class="line">    def show_directory(path):</div><div class="line">        list = os.listdir(path)</div><div class="line">        list.sort(key=lambda a: a.lower())</div><div class="line"></div><div class="line">        list = eval(json.dumps(list, ensure_ascii=False))</div><div class="line">        f = StringIO()</div><div class="line">        print path</div><div class="line">        path = str(path).strip(&quot;.&quot;)</div><div class="line">        displaypath = cgi.escape(path)</div><div class="line">        f.write(&apos;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;&apos;)</div><div class="line">        f.write(&quot;&lt;html&gt;\n&lt;title&gt;产品文档&lt;/title&gt;\n&quot;)</div><div class="line">        encoding = sys.getfilesystemencoding()</div><div class="line">        f.write(&apos;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=%s&quot;&gt;&apos; % encoding)</div><div class="line">        f.write(&quot;&lt;body&gt;\n&lt;h2&gt;最新产品文档列表&lt;/h2&gt;\n&quot;)</div><div class="line">        f.write(&quot;&lt;hr&gt;\n&lt;ul&gt;\n&quot;)</div><div class="line"></div><div class="line">        for name in list:</div><div class="line">            fullname = path + name</div><div class="line">            displayname = linkname = name</div><div class="line">            if os.path.splitext(name)[1] in app.config[&quot;IGNORED&quot;]:</div><div class="line">                continue</div><div class="line">            if name in app.config[&quot;IGNORED&quot;]:</div><div class="line">                continue</div><div class="line">            if os.path.isdir(fullname):</div><div class="line">                displayname = name + &quot;/&quot;</div><div class="line">                linkname = name + &quot;/&quot;</div><div class="line">            if os.path.islink(fullname):</div><div class="line">                displayname = name + &quot;@&quot;</div><div class="line">            if os.path.isdir(path + &quot;/&quot;+name):</div><div class="line">                if &quot;index.html&quot; in os.listdir(path + &quot;/&quot;+name):</div><div class="line">                    linkname = name + &quot;/index.html&quot;</div><div class="line">                    f.write(&apos;&lt;li&gt;&lt;a href=&quot;%s&quot;&gt;%s&lt;/a&gt;\n&apos;</div><div class="line">                            % (urllib.quote(linkname), cgi.escape(displayname)))</div><div class="line">            else:</div><div class="line">                f.write(&apos;&lt;li&gt;&lt;a href=&quot;%s&quot;&gt;%s&lt;/a&gt;\n&apos;</div><div class="line">                        % (urllib.quote(name), cgi.escape(displayname)))</div><div class="line">        f.write(&quot;&lt;/ul&gt;\n&lt;hr&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n&quot;)</div><div class="line">        length = f.tell()</div><div class="line">        f.seek(0)</div><div class="line">        resp = make_response(f.read())</div><div class="line">        return resp</div><div class="line"></div><div class="line">    @app.route(&apos;/&lt;path:filename&gt;&apos;)</div><div class="line">    @app.route(&apos;/&apos;, methods=[&apos;POST&apos;, &apos;GET&apos;])</div><div class="line">    def show_file(filename=&apos;&apos;):</div><div class="line">        global ROOT_DIR</div><div class="line">        ROOT_DIR = os.path.abspath(&apos;../../../share/&apos;)</div><div class="line">        print ROOT_DIR</div><div class="line">        if request.method == &apos;GET&apos;:</div><div class="line">            filename = safe_join(ROOT_DIR, &quot;out_put/&quot;+filename)</div><div class="line">            print filename</div><div class="line"></div><div class="line">            if os.path.isdir(filename):</div><div class="line">                return show_directory(filename)</div><div class="line">            if not os.path.isfile(filename):</div><div class="line">                raise NotFound()</div><div class="line">            return send_file(filename, as_attachment=False)</div><div class="line">    @app.before_request</div><div class="line">    def before_request():</div><div class="line">        create_path()</div><div class="line"></div><div class="line">    @app.after_request</div><div class="line">    def after_request(response):</div><div class="line">        return response</div><div class="line"></div><div class="line">    @app.errorhandler(404)</div><div class="line">    def url_not_found(error):</div><div class="line">        &quot;&quot;&quot;重新定义404报错&quot;&quot;&quot;</div><div class="line">        return make_response(jsonify(&#123;&apos;error&apos;: &apos;URL occurs errors&apos;&#125;), 404)</div><div class="line"></div><div class="line">    @app.errorhandler(400)</div><div class="line">    def params_not_found(error):</div><div class="line">        &quot;&quot;&quot;重新定义400报错&quot;&quot;&quot;</div><div class="line">        return make_response(jsonify(&#123;&apos;error&apos;: &apos;Params occurs errors&apos;&#125;), 400)</div><div class="line"></div><div class="line">    def get_locale():</div><div class="line">        return request.accept_languages.best_match(app.config[&apos;LANGUAGES&apos;].keys())</div><div class="line"></div><div class="line">    def allowed_file(filename):</div><div class="line">        return &apos;.&apos; in filename and filename.rsplit(&apos;.&apos;, 1)[1] in app.config[&apos;ALLOWED_EXTENSIONS&apos;]</div><div class="line"></div><div class="line">    def create_path():</div><div class="line">        upload_path = app.config[&quot;UPLOAD_FOLDER&quot;]</div><div class="line">        if not os.path.exists(upload_path):</div><div class="line">            os.makedirs(upload_path)</div></pre></td></tr></table></figure>
<h4 id="开发查看"><a href="#开发查看" class="headerlink" title="开发查看"></a>开发查看</h4><p>将<code>Flask</code>的服务部署到和共享文档同在的<code>Linux</code>机器上。</p>
<blockquote>
<p>小贴士：注意文件路径。</p>
</blockquote>
<p>通过<code>Supervisord</code>部署好之后，开发查看产品文档就非常方便，只需要知道<code>Flask</code>服务的<code>ip</code>和<code>port</code>即可，实现了局域网内共享。类如我们本地配置好的，:<code>http://192.168.1.100:8001</code></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1、配置Samba共享服务<br>2、通过Flask写的服务查看</p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;起因是需要让产品在Axure生成的产品文档方便在内部共享，之前有很多的思路，最后还是走了最简单的一条路。在Linux上搭建一个Samba服务
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(十七)——Fastlane总结</title>
    <link href="http://yoursite.com/2017/01/20/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%8D%81%E4%B8%83-%E2%80%94%E2%80%94Fastlane%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/01/20/持续集成实施-十七-——Fastlane总结/</id>
    <published>2017-01-20T05:48:28.000Z</published>
    <updated>2017-01-20T06:14:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、目标"><a href="#一、目标" class="headerlink" title="一、目标"></a>一、目标</h2><p>持续集成是一个不断迭代优化演进的过程，持续集成iOS打包，当前任务需要完成：</p>
<ul>
<li>内部测试版本：使用标准开发者的Developer证书签名的ipa文件。</li>
<li>公开测试版本：使用企业账户的Distribute InHouse证书签名的ipa文件。</li>
<li>AppStore版本：使用标准开发者的AppStore证书签名的ipa文件。</li>
<li>将打包结果推送公司Slack群</li>
<li>让测试和开发解耦开，测试随时自由打包<h2 id="二、初识"><a href="#二、初识" class="headerlink" title="二、初识"></a>二、初识</h2>一开始使用的是<code>xcodebuild</code>写的<code>shell</code>打包脚本，初次认识fastlane 的时候是去年的 10 月份，是老大开会提到了这样的以打包工具。仔细调研了一下，非常精细。它一个针对于 iOS 和 Android（后来才支持的）全方位自动化流程的工具套件。</li>
<li>deliver: Upload screenshots, metadata, and your app to the App Store</li>
<li>supply: Upload your Android app and its metadata to Google Play</li>
<li>snapshot: Automate taking localized screenshots of your iOS and tvOS apps on every device</li>
<li>screengrab: Automate taking localized screenshots of your Android app on every device</li>
<li>frameit: Quickly put your screenshots into the right device frames</li>
<li>pem: Automatically generate and renew your push notification profiles</li>
<li>sigh: Because you would rather spend your time building stuff than fighting provisioning</li>
<li>produce: Create new iOS apps on iTunes Connect and Dev Portal using the command line</li>
<li>cert: Automatically create and maintain iOS code signing certificates</li>
<li>spaceship: Ruby library to access the Apple Dev Center and iTunes Connect</li>
<li>pilot: The best way to manage your TestFlight testers and builds from your terminal</li>
<li>boarding: The easiest way to invite your TestFlight beta testers</li>
<li>gym: Building your iOS apps has never been easier</li>
<li>match: Easily sync your certificates and profiles across your team using Git</li>
<li>scan: The easiest way to run tests for your iOS and Mac apps<br>它可以集成打包，甚至上传AppStore和TestFlight，简直神器。<h3 id="三、使用Fastlane打包"><a href="#三、使用Fastlane打包" class="headerlink" title="三、使用Fastlane打包"></a>三、使用Fastlane打包</h3>下载fastlane，就三个命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div><div class="line">sudo gem install bundler</div><div class="line">sudo gem install fastlane</div></pre></td></tr></table></figure>
<p>可以查看一下 <code>fastlane -v</code>的版本，我们打包主要用到<code>gym</code>和上传命令<code>pilot</code>，其他工具略有研究，但是未深入，还要提醒，我都是用的命令行格式，未使用官方推荐的Fastfile的方式，主要是我对ruby不够了解，因为我也是个大菜鸟。附上打包命令。</p>
<p>gym打包，需要讲解的不多，DEVELOPMENT_TEAM等等解释，可以详细看这里<a href="https://dpogue.ca/articles/cordova-xcode8.html" target="_blank" rel="external">https://dpogue.ca/articles/cordova-xcode8.html</a><br>需要提醒的是 xcpretty_report_josn可以输出<strong>oclint需要的xcpretty执行之后的内容，这里可以oclint集成到一起</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line"></div><div class="line">#计时</div><div class="line">SECONDS=0</div><div class="line"></div><div class="line">#假设脚本放置在与项目相同的路径下</div><div class="line">project_path=$(pwd)</div><div class="line">#取当前时间字符串添加到文件结尾</div><div class="line">now=$(date +&quot;%Y_%m_%d_%H_%M&quot;)</div><div class="line">#取替换BundleVersion的时间字符串</div><div class="line">now_date=$(date +&quot;%Y%m%d%H%M&quot;)</div><div class="line">#获取当前脚本路径</div><div class="line">file_path=$(cd `dirname $0`; pwd)</div><div class="line"></div><div class="line">#指定项目的scheme名称</div><div class="line">scheme=&quot;MiFit&quot;</div><div class="line">#指定要打包的配置名</div><div class="line">configuration=&quot;Release&quot;</div><div class="line">#指定打包所使用的输出方式，目前支持app-store, package, ad-hoc, </div><div class="line">enterprise, development, 和developer-id，即xcodebuild的method</div><div class="line">参数</div><div class="line">export_method=&quot;app-store&quot;</div><div class="line"></div><div class="line">#指定项目地址</div><div class="line">workspace_path=&quot;xx&quot;</div><div class="line">#指定输出路径</div><div class="line">output_path=&quot;$project_path/APP/$&#123;now&#125;_out&quot;</div><div class="line">#指定输出归档文件地址</div><div class="line">archive_path=&quot;xx&quot;</div><div class="line">#指定输出ipa地址</div><div class="line">ipa_path=&quot;$output_path/&quot;</div><div class="line">#指定输出ipa名称</div><div class="line">ipa_name=&quot;xx&quot;</div><div class="line">#指定image和ipa最后路径</div><div class="line">image_path=&quot;$project_path/APP/image_out/&quot;</div><div class="line">#工程内infoplist</div><div class="line">project_infoplist_path=&quot;$&#123;project_path&#125;/xx/Info.plist</div><div class="line">#bundleIdentifier</div><div class="line">bundle_id=&quot;xx&quot;</div><div class="line">#证书名称</div><div class="line">rightDistributionSign=&quot;xx&quot;</div><div class="line"></div><div class="line">#手动证书管理方式</div><div class="line">sed -i &apos;&apos; &apos;s/ProvisioningStyle = Automatic;/</div><div class="line">ProvisioningStyle = Manual;/g&apos; &quot;$project_path/</div><div class="line">MiFit.xcodeproj/project.pbxproj&quot;</div><div class="line"></div><div class="line">#development_team名称</div><div class="line">DEVELOPMENT_TEAM=&quot;xx&quot;</div><div class="line">#PROVISIONING_PROFILE_SPECIFIER名称</div><div class="line">PROVISIONING_PROFILE_SPECIFIER=&quot;xx&quot;</div><div class="line"></div><div class="line">#ExoptionPlist地址</div><div class="line">ExoptionPlist=&quot;$&#123;file_path&#125;/Mifit-appstore.plist&quot;</div><div class="line"></div><div class="line">#修改info_plist中BundleVersion</div><div class="line">bundleBuildVersion=$(/usr/libexec/PlistBuddy -c &quot;print</div><div class="line"> CFBundleVersion&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</div><div class="line">if [ &quot;$&#123;bundleBuildVersion&#125;&quot; != &quot;$&#123;now_date&#125;&quot; ]; then</div><div class="line">	/usr/libexec/PlistBuddy -c &quot;set CFBundleVersion</div><div class="line">	$&#123;now_date&#125;&quot; $&#123;project_infoplist_path&#125;</div><div class="line">fi;</div><div class="line"></div><div class="line">#修改info_plist中BundleShortVersion,由于上传appstore对此有严格要求,故在不传入bundleShortVersion时，自动修正</div><div class="line">bundleShortVersion=$(/usr/libexec/PlistBuddy -c &quot;print </div><div class="line">CFBundleShortVersionString&quot; $&#123;project_infoplist_path&#125;)</div><div class="line">build_version=$1</div><div class="line">if [ $1 != &quot;&quot; ]; then</div><div class="line">	/usr/libexec/PlistBuddy -c &quot;set CFBundleShortVersionString </div><div class="line">	$&#123;build_version&#125;&quot; $&#123;project_infoplist_path&#125;</div><div class="line">else</div><div class="line">	arr=($&#123;bundleShortVersion//./ &#125;)</div><div class="line">	if [ &quot;$&#123;#arr[@]&#125;&quot; -gt 3 ] ; then</div><div class="line">	    bundleShortVersion=$&#123;arr[0]&#125;&quot;.&quot;$&#123;arr[1]&#125;&quot;.&quot;$(($</div><div class="line">	    &#123;arr[2]&#125;+1))</div><div class="line">	elif [ &quot;$&#123;#arr[@]&#125;&quot; -eq 3 ] ; then</div><div class="line">		bundleShortVersion=$&#123;bundleShortVersion&#125;</div><div class="line">	else</div><div class="line">	    bundleShortVersion=$&#123;bundleShortVersion&#125;&quot;.1&quot;</div><div class="line">	fi;</div><div class="line">	/usr/libexec/PlistBuddy -c &quot;set CFBundleShortVersionString </div><div class="line">	$&#123;bundleShortVersion&#125;&quot; $&#123;project_infoplist_path&#125;</div><div class="line">fi;</div><div class="line"></div><div class="line">#修改info_plist中bundleid</div><div class="line">bundleIdentifier=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleIdentifier&quot; $&#123;project_infoplist_path&#125;)</div><div class="line">if [ &quot;$&#123;bundleIdentifier&#125;&quot; != &quot;\$(PRODUCT_BUNDLE_IDENTIFIER)&quot; ]; then</div><div class="line">	if [ &quot;$&#123;bundleIdentifier&#125;&quot; != &quot;$&#123;bundle_id&#125;&quot; ]; then</div><div class="line">		/usr/libexec/PlistBuddy -c &quot;set CFBundleIdentifier </div><div class="line">		$&#123;bundle_id&#125;&quot; $&#123;project_infoplist_path&#125;</div><div class="line">	fi;</div><div class="line">fi;</div><div class="line">#获取执行命令时的commit message</div><div class="line">commit_msg=&quot;$1&quot;</div><div class="line">#输出设定的变量值</div><div class="line">echo &quot;===workspace path: $&#123;workspace_path&#125;===&quot;</div><div class="line">echo &quot;===archive path: $&#123;archive_path&#125;===&quot;</div><div class="line">echo &quot;===build version: $&#123;build_version&#125;===&quot;</div><div class="line">echo &quot;===ipa path: $&#123;ipa_path&#125;===&quot;</div><div class="line">echo &quot;===ipa name: $&#123;ipa_name&#125;===&quot;</div><div class="line">echo &quot;===export method: $&#123;export_method&#125;===&quot;</div><div class="line">echo &quot;===commit msg: $1===&quot;</div><div class="line"></div><div class="line">#先清空前一次build</div><div class="line">rm -rf ~/Library/Developer/Xcode/DerivedData/*</div><div class="line">PROVISIONING_PROFILE_SPECIFIER=&quot;&#123;PROVISIONING_PROFILE_SPECIF</div><div class="line">IER&#125;&quot; </div><div class="line">fastlane gym</div><div class="line">--workspace $&#123;workspace_path&#125; </div><div class="line">--scheme $&#123;scheme&#125; </div><div class="line">--clean true </div><div class="line">--configuration $&#123;configuration&#125; </div><div class="line">--xcargs </div><div class="line">&quot;PRODUCT_BUNDLE_IDENTIFIER=&apos;$&#123;bundle_id&#125;&apos; </div><div class="line">DEVELOPMENT_TEAM=&apos;$&#123;DEVELOPMENT_TEAM&#125;&apos;&quot; </div><div class="line">--export_method $&#123;export_method&#125; </div><div class="line">--archive_path $&#123;archive_path&#125; </div><div class="line">--codesigning_identity &quot;$&#123;rightDistributionSign&#125;&quot; </div><div class="line">--export_options $&#123;ExoptionPlist&#125; </div><div class="line">--output_directory $&#123;ipa_path&#125;</div><div class="line">--output_name $&#123;ipa_name&#125; || exit</div><div class="line">#复制ipa到指定最后路径</div><div class="line">if [ ! -d &quot;$&#123;image_path&#125;&quot; ]; then</div><div class="line">  mkdir -p $&#123;image_path&#125;</div><div class="line">fi</div><div class="line">rm -rf &quot;$&#123;image_path&#125;MiFit.ipa&quot;</div><div class="line">rm -rf &quot;$&#123;image_path&#125;MiFit.app.dSYM.zip&quot;</div><div class="line">\cp -fr &quot;$&#123;ipa_path&#125;$&#123;ipa_name&#125;&quot; &quot;$&#123;image_path&#125;&quot;</div><div class="line">\cp -fr &quot;$&#123;ipa_path&#125;MiFit.app.dSYM.zip&quot; &quot;$&#123;image_path&#125;&quot;</div><div class="line"></div><div class="line">#输出总用时</div><div class="line">echo &quot;===Finished. Total time: $&#123;SECONDS&#125;s===&quot;</div></pre></td></tr></table></figure>
<h3 id="四、集成推送Slack"><a href="#四、集成推送Slack" class="headerlink" title="四、集成推送Slack"></a>四、集成推送Slack</h3><p>讲讲其他遇到的坑和解决方案。<br>由于主要使用fastlane中gym打包，但是这次需要注意的我们的需求是:</p>
<ul>
<li>需要分别打inhouse，adhoc，appstore的包</li>
<li>inhouse和adhoc作为内测，需要更换显示图标，加上内测字样。</li>
<li>inhouse包需要上传蒲公英（之前选择的Fir因为部分收费要求放弃了），需要跟slack对接，并且自动推送。</li>
</ul>
<hr>
<h5 id="1、分别打三种包，对证书和rightProvision了解的不够透彻？"><a href="#1、分别打三种包，对证书和rightProvision了解的不够透彻？" class="headerlink" title="1、分别打三种包，对证书和rightProvision了解的不够透彻？"></a>1、分别打三种包，对证书和<code>rightProvision</code>了解的不够透彻？</h5><p>解决：把三种证书都从开发那里要过来，然后将自己的APPLE ID升级到开发者<code>Admin</code>状态，就具有了三种证书的使用权限，然后跟开发一一对接，对每个包分别对应的证书了解并整理，打包的时候一一对应上就好。这个过程中，收获的是对xcodebuild的method参数有更深的了解，其实inhouse，adhoce，appstore分别对应的打包方式是<code>enterprise</code>，<code>ad-hoc</code>，<code>app-store</code>。</p>
<h5 id="2、需要更换inhouse的图标？"><a href="#2、需要更换inhouse的图标？" class="headerlink" title="2、需要更换inhouse的图标？"></a>2、需要更换inhouse的图标？</h5><p>解决：之前想通过是打包的时候指向不同的<code>target</code>，后来的解决方案是直接替换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for file in os.listdir(appIconPath):</div><div class="line">    if &quot;.png&quot; in file:</div><div class="line">        for appicon in os.listdir(replaceAppIconPath):</div><div class="line">            if file == appicon:</div><div class="line">                shutil.copy(replaceAppIconPath+&apos;/&apos;+appicon, </div><div class="line">                appIconPath+&apos;/&apos;+file)</div></pre></td></tr></table></figure>
<p>但是需要注意的是像素和尺寸需要保持一致，设计同学的帮忙很必要。</p>
<h5 id="3、和slack对接"><a href="#3、和slack对接" class="headerlink" title="3、和slack对接"></a>3、和slack对接</h5><p>解决：其实我觉得slack真的非常好用，因为它提供了各种整合持续集成的api，这里特别佩服我们老大对这块内容的重视，slack和jenkins集成非常方便。<br>只是网速有点不靠谱。slack api地址:<code>https://api.slack.com/docs/message-guidelines</code><br>附上我写的脚本，借助slack web api推送信息到slack，并且可以取出jenkins中执行者的信息:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line">import sys</div><div class="line">import time</div><div class="line">import requests</div><div class="line">import re</div><div class="line">from slacker import Slacker</div><div class="line"></div><div class="line">def send(job_url, job_name, starters, build_timestamp, </div><div class="line">workspace, build_cause, git_branch, change_log, text, </div><div class="line">userid):</div><div class="line">    &quot;&quot;&quot;执行结果推送slack，可选个人和channel&quot;&quot;&quot;</div><div class="line">    api_token = &quot;xxxx&quot;</div><div class="line">    slack = Slacker(api_token, 100)</div><div class="line">    data = [&#123;</div><div class="line">        &quot;fallback&quot;: &quot;Required plain-text summary of the </div><div class="line">        attachment.&quot;,</div><div class="line">        &quot;color&quot;: &quot;#36a64f&quot;,</div><div class="line">        &quot;fields&quot;: [</div><div class="line">            &#123;</div><div class="line">                &quot;title&quot;: &quot;Job name&quot;,</div><div class="line">                &quot;value&quot;: job_name,</div><div class="line">                &quot;short&quot;: True</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;title&quot;: &quot;Build Trigger&quot;,</div><div class="line">                &quot;value&quot;: starters,</div><div class="line">                &quot;short&quot;: True</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;title&quot;: &quot;Build Time&quot;,</div><div class="line">                &quot;value&quot;: build_timestamp,</div><div class="line">                &quot;short&quot;: True</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;title&quot;: &quot;Build Workspace&quot;,</div><div class="line">                &quot;value&quot;: workspace,</div><div class="line">                &quot;short&quot;: True</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;title&quot;: &quot;Root Build Cause&quot;,</div><div class="line">                &quot;value&quot;: build_cause,</div><div class="line">                &quot;short&quot;: True</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;title&quot;: &quot;GIT_BRANCH&quot;,</div><div class="line">                &quot;value&quot;: git_branch,</div><div class="line">                &quot;short&quot;: True</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;title&quot;: &quot;Job url&quot;,</div><div class="line">                &quot;value&quot;: job_url,</div><div class="line">            &#125;,</div><div class="line">            &#123;</div><div class="line">                &quot;title&quot;: &quot;CHANGE_LOG&quot;,</div><div class="line">                &quot;value&quot;: change_log,</div><div class="line">            &#125;</div><div class="line"></div><div class="line">        ],</div><div class="line">        &quot;footer&quot;: &quot;XX公司&quot;,</div><div class="line">        &quot;ts&quot;: time.time()</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">    try_times = 0</div><div class="line">    while try_times &lt; 5:</div><div class="line">        try:</div><div class="line">            slack.chat.post_message(userid, text=text, </div><div class="line">        attachments=data)</div><div class="line">            return &quot;push to slack failed&quot;</div><div class="line">        except Exception as e:</div><div class="line">            time.sleep(50)</div><div class="line">            try_times += 1</div><div class="line">        if try_times &gt;= 5:</div><div class="line">            raise Exception(&apos;push to slack failed&apos;)</div><div class="line"></div><div class="line">def get_content(job_url):</div><div class="line">    &quot;&quot;&quot;取出console log全部内容&quot;&quot;&quot;</div><div class="line">    url = job_url + &quot;consoleText/api/json&quot;</div><div class="line">    headers = &#123;</div><div class="line">    	&quot;Content-Type&quot;: &quot;application/json&quot;,</div><div class="line">    	&quot;Accept&quot;: &quot;application/json&quot;</div><div class="line">    &#125;</div><div class="line">    response = requests.get(url, auth=(&quot;xx&quot;, &quot;xx&quot;))</div><div class="line">    assert response.status_code == requests.codes.ok</div><div class="line">    return response.content</div><div class="line"></div><div class="line">def get_trigger(result):</div><div class="line">    &quot;&quot;&quot;取出构建者&quot;&quot;&quot;</div><div class="line">    trigger_user = re.findall(r&quot;Started by&quot;, result)</div><div class="line">    trigger_other = re.findall(r&quot;Triggered by&quot;, result)</div><div class="line">    starters = &quot;&quot;</div><div class="line">    if len(trigger_user) &gt; 0:</div><div class="line">        starters = re.findall(r&quot;Started by(.*)&quot;, result)</div><div class="line">        [0].lstrip()</div><div class="line">    elif len(trigger_other) &gt; 0:</div><div class="line">        starters = re.findall(r&quot;Triggered by(.*)&quot;, result)</div><div class="line">ers = re[0].lstrip()</div><div class="line">    return starters</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    if len(sys.argv) &gt;= 2:</div><div class="line">        job_url = sys.argv[1]</div><div class="line">        job_name = sys.argv[2]</div><div class="line">        build_timestamp = sys.argv[3]</div><div class="line">        workspace = sys.argv[4] </div><div class="line">        build_cause = sys.argv[5]</div><div class="line">        git_branch = sys.argv[6]</div><div class="line">        text = sys.argv[7]</div><div class="line">        userid = sys.argv[8]</div><div class="line">        change_log = sys.argv[9]</div><div class="line">        result = get_content(job_url)</div><div class="line">        starters = get_trigger(result)</div><div class="line">        result = get_content(job_url)</div><div class="line">        starters = get_trigger(result)</div><div class="line">        send_userid = [&quot;#xx&quot;, userid]</div><div class="line">        for i in send_userid:</div><div class="line">            send(job_url, job_name, starters, end(job_url,build_timestamp, workspace, build_cause, git_branch, </div><div class="line">            change_log, text, i)</div></pre></td></tr></table></figure>
<p>然后构造请求，发送即可，详细不表。</p>
<h5 id="4、因为我们app两个平台用的xcode版本不一致，需要升级到xcode8，需要将自动管理改为手动管理证书。"><a href="#4、因为我们app两个平台用的xcode版本不一致，需要升级到xcode8，需要将自动管理改为手动管理证书。" class="headerlink" title="4、因为我们app两个平台用的xcode版本不一致，需要升级到xcode8，需要将自动管理改为手动管理证书。"></a>4、因为我们app两个平台用的xcode版本不一致，需要升级到xcode8，需要将自动管理改为手动管理证书。</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;&apos; &apos;s/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g&apos; </div><div class="line">&quot;$project_path/project.pbxproj&quot;</div></pre></td></tr></table></figure>
<h5 id="5、pod-install总是出现问题，分析可能是因为网络或者本机pod安装有问题。"><a href="#5、pod-install总是出现问题，分析可能是因为网络或者本机pod安装有问题。" class="headerlink" title="5、pod install总是出现问题，分析可能是因为网络或者本机pod安装有问题。"></a>5、pod install总是出现问题，分析可能是因为网络或者本机pod安装有问题。</h5><p>若是pod问题，可以通过升级gem解决。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure>
<blockquote>
<p>小贴士：谨慎使用sudo gem update</p>
</blockquote>
<h5 id="6、结果展示"><a href="#6、结果展示" class="headerlink" title="6、结果展示"></a>6、结果展示</h5><p>这是我们已经落地的工程，送上Slack推送截图。<img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/fastlane00.png" alt="Slack截图"></p>
<h3 id="五、集成推送TestFlight"><a href="#五、集成推送TestFlight" class="headerlink" title="五、集成推送TestFlight"></a>五、集成推送TestFlight</h3><p>Testflight当前已经被苹果公司收购并完善了功能，可以分发内测，作为提升app质量有很好的推动作用。推送TestFlight主要借助<code>fastlane pilot</code><br>看到pilot是最好的方式管理你的TestFlight 测试人员和从终端构建的工具。</p>
<blockquote>
<p>小贴士：上传TestFlight的ipa必须打包方式是appstore，且版本号应该为3位并高于已经在线上Appstore可以下载的版本。</p>
</blockquote>
<h5 id="1、上传脚本"><a href="#1、上传脚本" class="headerlink" title="1、上传脚本"></a>1、上传脚本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">set -x</div><div class="line">#计时</div><div class="line">SECONDS=0</div><div class="line"></div><div class="line">#假设脚本放置在与项目相同的路径下</div><div class="line">project_path=$(pwd)</div><div class="line">#取当前时间字符串添加到文件结尾</div><div class="line">now=$(date +&quot;%Y_%m_%d_%H_%M&quot;)</div><div class="line">#取替换BundleVersion的时间字符串</div><div class="line">now_date=$(date +&quot;%Y%m%d%H%M&quot;)</div><div class="line">#获取当前脚本路径</div><div class="line">file_path=$(cd `dirname $0`; pwd)</div><div class="line"></div><div class="line">#上传用户的username</div><div class="line">username=&quot;xx&quot;</div><div class="line">#上传用户App id</div><div class="line">apple_id=&quot;xx&quot;</div><div class="line">#bundleIdentifier</div><div class="line">bundle_id=&quot;xxx&quot;</div><div class="line">#指定image和ipa最后路径</div><div class="line">ipa_path=&quot;$project_path/xx.ipa&quot;</div><div class="line">#上传team_id</div><div class="line">team_id=&quot;xxxx&quot;</div><div class="line">#上传team_name</div><div class="line">team_name=&quot;xxx&quot;</div><div class="line">#上传dev_portal_team_id</div><div class="line">dev_portal_team_id=&quot;xxx&quot;</div><div class="line">#上传itc_provider</div><div class="line">itc_provider=&quot;xxx&quot;</div><div class="line">distribute_external=$1</div><div class="line">changelog=&quot;xxxx&quot;</div><div class="line">beta_app_description=&quot;xxxx&quot;</div><div class="line">#反馈邮箱</div><div class="line">email=&quot;xxxx&quot;</div><div class="line">group=$2</div><div class="line"></div><div class="line">if [ -z &quot;$2&quot; ]; then</div><div class="line">	group=&quot;xxx&quot;</div><div class="line">fi</div><div class="line">#执行上传testflight</div><div class="line">pilot upload --verbose --username $&#123;username&#125; --app_identifier $&#123;bundle_id&#125; </div><div class="line">--changelog $&#123;changelog&#125; -d $&#123;beta_app_description&#125; </div><div class="line">--ipa $&#123;ipa_path&#125; --distribute_external $&#123;distribute_external&#125; </div><div class="line">--apple_id $&#123;apple_id&#125; --team_id $&#123;team_id&#125; </div><div class="line">--team_name &quot;$&#123;team_name&#125;&quot; --dev_portal_team_id $&#123;dev_portal_team_id&#125; </div><div class="line">--itc_provider &quot;$&#123;itc_provider&#125;&quot; --beta_app_feedback_email &quot;$&#123;email&#125;&quot; | exit</div><div class="line"></div><div class="line">#输出总用时</div><div class="line">echo &quot;===Finished. Total time: $&#123;SECONDS&#125;s===&quot;</div></pre></td></tr></table></figure>
<p>脚本中的例如team_id等这些值，对于开发或者测试来说应该都不陌生，虽然脚本简单，但是能方便的上传TestFlight，并且分发外部测试，真的非常方便。</p>
<h5 id="2、结果展示"><a href="#2、结果展示" class="headerlink" title="2、结果展示"></a>2、结果展示</h5><p>最后集成到jenkins，可以看到结果：<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/fastlane01.png" alt="推送TestFlight"><br>看到箭头指示的出现，代表已经成功的分发测试，可以去Testflight app下载安装新版本了。</p>
<h3 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h3><p>持续集成工作的开展不是一蹴而就的，iOS打包集成涉及到各种证书环节，需要仔细理清。</p>
<h3 id="七、相关文档"><a href="#七、相关文档" class="headerlink" title="七、相关文档"></a>七、相关文档</h3><ul>
<li><p><a href="https://github.com/KrauseFx/fastlane/tree/master/docs" target="_blank" rel="external">fastlane</a>:<a href="https://github.com/KrauseFx/fastlane/tree/master/docs" target="_blank" rel="external">https://github.com/KrauseFx/fastlane/tree/master/docs</a></p>
</li>
<li><p><a href="https://api.slack" target="_blank" rel="external">slack</a>:<a href="https://api.slack.com/methods" target="_blank" rel="external">https://api.slack.com/methods</a></p>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、目标&quot;&gt;&lt;a href=&quot;#一、目标&quot; class=&quot;headerlink&quot; title=&quot;一、目标&quot;&gt;&lt;/a&gt;一、目标&lt;/h2&gt;&lt;p&gt;持续集成是一个不断迭代优化演进的过程，持续集成iOS打包，当前任务需要完成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内部测试版本：使用标
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(十六)——Whistle抓包</title>
    <link href="http://yoursite.com/2017/01/18/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%8D%81%E5%85%AD-%E2%80%94%E2%80%94Whistle%E6%8A%93%E5%8C%85/"/>
    <id>http://yoursite.com/2017/01/18/持续集成实施-十六-——Whistle抓包/</id>
    <published>2017-01-18T06:01:02.000Z</published>
    <updated>2017-01-18T06:25:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近需要抓包Axure软件发出的请求，之前一直使用的<code>Charles</code>，挺稳定的一个工具，最近不知道抽什么风，然后一番搜索之后，发现了<code>whistle</code>，简直神器，配置还非常简单，由于只在<code>MAC</code>上有使用体验，就简单介绍一下。</p>
<h3 id="1、安装Node"><a href="#1、安装Node" class="headerlink" title="1、安装Node"></a>1、安装Node</h3><p>whistle支持v0.10.0以上版本的Node，为获取更好的性能，推荐安装最新版本的Node。</p>
<p>如果你的系统已经安装了v0.10.0以上版本的Node，可以忽略此步骤，直接进入安装whistle的步骤，否则：</p>
<p>访问<a href="https://nodejs.org/" target="_blank" rel="external">https://nodejs.org/</a> ，安装LTS版本的Node，默认安装即可。<br>安装完Node后，执行下面命令，查看当前Node版本</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ node -v</div><div class="line">v7.1.0</div></pre></td></tr></table></figure>
<p>如果能正常输出Node的版本号，表示Node已安装成功(Windows系统可能需要重新打开cmd)。</p>
<h3 id="2-安装whistle"><a href="#2-安装whistle" class="headerlink" title="2. 安装whistle"></a>2. 安装whistle</h3><p>Node安装成功后，执行如下npm命令安装whistle （Mac或Linux的非root用户需要在命令行前面加sudo，如：sudo npm install -g whistle）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g whistle</div></pre></td></tr></table></figure>
<p>whistle安装完成后，执行命令 whistle help 或 w2 help，查看whistle的帮助信息</p>
<p>$ w2 help</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">Usage: w2 &lt;command&gt; [options]</div><div class="line"></div><div class="line">  Commands:</div><div class="line"></div><div class="line">    run       Start a front service</div><div class="line">    start     Start a background service</div><div class="line">    stop      Stop current background service</div><div class="line">    restart   Restart current background service</div><div class="line">    help      Display help information</div><div class="line"></div><div class="line">  Options:</div><div class="line"></div><div class="line">    -h, --help                                      output </div><div class="line">    usage information</div><div class="line">    -d, --debug                                     debug </div><div class="line">    mode</div><div class="line">    -l, --localUIHost [hostname]                    local ui </div><div class="line">    host(local.whistlejs.com by default)</div><div class="line">    -n, --username [username]                       login </div><div class="line">    username</div><div class="line">    -w, --password [password]                       login </div><div class="line">    password</div><div class="line">    -S, --storage [newStorageDir]                   the new </div><div class="line">    local storage directory</div><div class="line">    -C, --copy [storageDir]                         copy </div><div class="line">    storageDir to newStorageDir</div><div class="line">    -p, --port [port]                               whistle </div><div class="line">    port(8899 by default)</div><div class="line">    -m, --middlewares [script path or module name]  express </div><div class="line">    middlewares path(as: xx,yy/zz.js)</div><div class="line">    -u, --uipath [script path]                      web ui </div><div class="line">    plugin path</div><div class="line">    -t, --timeout [ms]                              request </div><div class="line">    timeout(36000 ms by default)</div><div class="line">    -s, --sockets [number]                          max </div><div class="line">    sockets(12 by default)</div><div class="line">    -V, --version                                   output </div><div class="line">    the version number</div><div class="line">    -c, --command &lt;command&gt;                         command </div><div class="line">    parameters (&quot;node --harmony&quot;)</div></pre></td></tr></table></figure>
<p>如果能正常输出whistle的帮助信息，表示whistle已安装成功。</p>
<h3 id="3-启动whistle"><a href="#3-启动whistle" class="headerlink" title="3. 启动whistle"></a>3. 启动whistle</h3><p>最新版本的whistle支持三种等价的命令whistle、w2、wproxy</p>
<p>启动whistle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ w2 start</div></pre></td></tr></table></figure>
<p>Note: 如果要防止其他人访问配置页面，可以在启动时加上登录用户名和密码 -n yourusername -w yourpassword。</p>
<p>重启whsitle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ w2 restart</div></pre></td></tr></table></figure>
<p>停止whistle:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ w2 stop</div></pre></td></tr></table></figure>
<p>调试模式启动whistle(主要用于查看whistle的异常及插件开发):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ w2 run</div></pre></td></tr></table></figure>
<p>启动完whistle后，最后一步需要配置代理。</p>
<h3 id="4-配置代理"><a href="#4-配置代理" class="headerlink" title="4. 配置代理"></a>4. 配置代理</h3><p><strong>配置信息</strong><br>代理服务器：127.0.0.1(如果部署在远程服务器或虚拟机上，改成对应服务器或虚拟机的ip即可)<br>默认端口：8899(如果端口被占用，可以在启动是通过 -p 来指定新的端口，更多信息可以通过执行命令行 w2 help (v0.7.0及以上版本也可以使用w2 help) 查看)<br>勾选上 对所有协议均使用相同的代理服务器</p>
<p>代理配置方式(把上面配置信息配置上即可)</p>
<ul>
<li><p>直接配置系统代理：</p>
<p><a href="http://jingyan.baidu.com/article/a378c960849144b3282830dc.html" target="_blank" rel="external">Mac</a></p>
</li>
<li><p>安装浏览器代理插件 (推荐)<br>安装Chrome代理插件： whistle-for-chrome</p>
</li>
</ul>
<p><strong>访问配置页面</strong><br>启动whistle及配置完代理后，用Chrome浏览器(由于css兼容性问题界面只支持Chrome浏览器)访问配置页面，如果能正常打开页面，whistle安装启动完毕，可以开始使用。<br>可以通过以下两种方式来访问配置页面：</p>
<ul>
<li>方式1：域名访问 <a href="http://local.whistlejs.com/" target="_blank" rel="external">http://local.whistlejs.com/</a></li>
<li>方式2：通过ip+端口来访问，形式如 <a href="http://whistleServerIP:whistlePort+1/" target="_blank" rel="external">http://whistleServerIP:whistlePort+1/</a> e.g. <a href="http://127.0.0.1:8900" target="_blank" rel="external">http://127.0.0.1:8900</a><br>Https</li>
</ul>
<p>用来下载根证书、隐藏connect类型的请求、开启Https拦截功能。</p>
<h3 id="5-Https"><a href="#5-Https" class="headerlink" title="5. Https"></a>5. Https</h3><p><strong>安装根证书</strong><br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/whistlejs00.png" alt="证书安装"><br>如上图下载完根证书后点击rootCA.crt文件，弹出根证书安装对话框。</p>
<p><strong>开启拦截Https</strong><br>图中的打开的对话框有两个checkbox：<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/whistlejs01.png" alt="开启拦截"></p>
<ul>
<li>Hide HTTPS CONNECTs：隐藏connect类型的请求</li>
<li>Intercept HTTPS CONNECTs：开启Https拦截功能，只有勾上这个checkbox及装好根证书，whistle才能看到HTTPS、Websocket的请求</li>
</ul>
<p>最后效果如图所示：<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/whistlejs02.png" alt="Axure抓包"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近需要抓包Axure软件发出的请求，之前一直使用的&lt;code&gt;Charles&lt;/code&gt;，挺稳定的一个工具，最近不知道抽什么风，然后一番搜索之后，发现了&lt;code&gt;whistle&lt;/code&gt;，简直神器，配置还非常简单，由于只在&lt;code&gt;MAC&lt;/code&gt;上有使用体
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask部署</title>
    <link href="http://yoursite.com/2017/01/03/Flask%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2017/01/03/Flask部署/</id>
    <published>2017-01-03T00:37:05.000Z</published>
    <updated>2017-01-03T01:20:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>已经搭建好了一个Flask应用，当前启动方式是<code>gunicorn -b 0.0.0.0:8000 wsgi:application</code>,但是每次部署的时候都需要先<code>cat router.pid</code>，然后<code>kill</code>掉进程，代码更新后，再重启应用。显得有待呢让麻烦，网上有一票的关于Flask部署，以<code>gunicorn + flask ++ supervisor</code>部署测试。</p>
<h3 id="创建虚拟环境-virtualenv"><a href="#创建虚拟环境-virtualenv" class="headerlink" title="创建虚拟环境 virtualenv"></a>创建虚拟环境 virtualenv</h3><p>在一个系统中创建不同的 Python 隔离环境，相互之间还不会影响，为了使系统保持干净，遂决定用 virtualenv 跑应用程序，创建一个容易识别的目录，开始安装，再创建项目目录 super，然后激活环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sudo pip install virtualenv</div><div class="line">mkdir ~/Documents/web_project &amp;&amp; cd ~/Documents/web_project</div><div class="line">virtualenv env</div><div class="line">source env/bin/activate</div></pre></td></tr></table></figure></p>
<h3 id="安装各种需求库"><a href="#安装各种需求库" class="headerlink" title="安装各种需求库"></a>安装各种需求库</h3><p>创建了虚拟环境以后，需要在虚拟环境里面安装各种依赖库。很简单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install -r requiremensts.txt</div></pre></td></tr></table></figure></p>
<p>一系列时间等待以后，就安装好了。</p>
<h3 id="生成supervisor配置文件"><a href="#生成supervisor配置文件" class="headerlink" title="生成supervisor配置文件"></a>生成supervisor配置文件</h3><p>supervisor是守护进程的工具，首先需要生成配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/Documents/web_project</div><div class="line">echo_supervisord_conf &gt; supervisor.conf</div></pre></td></tr></table></figure></p>
<p>然后修改配置文件，我选择的方式是全部删除当前内容，放入我已经测试写好的配置内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">[unix_http_server]</div><div class="line">file=/tmp/supervisor.sock   ; (the path to the socket file)</div><div class="line"></div><div class="line"></div><div class="line">[inet_http_server]         ; inet (TCP) server disabled by default</div><div class="line">port=0.0.0.0:9001       ; (ip_address:port specifier, *:port for all iface)</div><div class="line">username=xx              ; (default is no username (open server))</div><div class="line">password=xx               ; (default is no password (open server))</div><div class="line"></div><div class="line">[supervisord]</div><div class="line">logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log)</div><div class="line">logfile_maxbytes=50MB        ; (max main logfile bytes b4 rotation;default 50MB)</div><div class="line">logfile_backups=10           ; (num of main logfile rotation backups;default 10)</div><div class="line">loglevel=info                ; (log level;default info; others: debug,warn,trace)</div><div class="line">pidfile=/tmp/supervisord.pid ; (supervisord pidfile;default supervisord.pid)</div><div class="line">nodaemon=false               ; (start in foreground if true;default false)</div><div class="line">minfds=1024                  ; (min. avail startup file descriptors;default 1024)</div><div class="line">minprocs=200                 ; (min. avail process descriptors;default 200)</div><div class="line"></div><div class="line">[rpcinterface:supervisor]</div><div class="line">supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface</div><div class="line"></div><div class="line">[supervisorctl]</div><div class="line">serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL  for a unix socket</div><div class="line">serverurl=http://0.0.0.0:9001 ; use an http:// url to specify an inet socket</div><div class="line">username=xx              ; should be same as http_username if set</div><div class="line">password=xx                ; should be same as http_password if set</div><div class="line">;prompt=mysupervisor         ; cmd line prompt (default &quot;supervisor&quot;)</div><div class="line">;history_file=~/.sc_history  ; use readline history if available</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">[include]</div><div class="line">files = /etc/supervisor/*.conf</div><div class="line"></div><div class="line">[program:webhook]</div><div class="line">directory = /Users/djx/Documents/web_project/ci_ios/webhook ; 程序的启动目录</div><div class="line">command = /Users/djx/Documents/web_project/env/bin/gunicorn -b 0.0.0.0:8000 wsgi:application  ; 启动命令，可以看出与手动在命令行启动的命令是一样的</div><div class="line">autostart = true     ; 在 supervisord 启动的时候也自动启动</div><div class="line">startsecs = 0        ; 启动 5 秒后没有异常退出，就当作已经正常启动了</div><div class="line">autorestart = false   ; 程序异常退出后自动重启</div><div class="line">startretries = 0     ; 启动失败自动重试次数，默认是 3</div><div class="line">redirect_stderr = true  ; 把 stderr 重定向到 stdout，默认 false</div><div class="line">stdout_logfile_maxbytes = 20MB  ; stdout 日志文件大小，默认 50MB</div><div class="line">stdout_logfile_backups = 20     ; stdout 日志文件备份数</div><div class="line">stdout_logfile=/tmp/gunicorn.log</div><div class="line">stderr_logfile=/tmp/gunicorn.err</div></pre></td></tr></table></figure></p>
<p>可以通过<code>supervisor -c supervisor.conf</code>启动。<br>而且有一个web界面可以管理查看进程。<br><code>http://127.0.0.1:9001</code><br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/supervisord01.png" alt="Supervisord进程管理界面"></p>
<h3 id="supervisor相关命令介绍"><a href="#supervisor相关命令介绍" class="headerlink" title="supervisor相关命令介绍"></a>supervisor相关命令介绍</h3><p>supervisor的基本使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">supervisord -c supervisor.conf    </div><div class="line">supervisorctl -c supervisor.conf status                  查看supervisor的状态                                      </div><div class="line">supervisorctl -c supervisor.conf reload                  重新载入 配置文件</div><div class="line">supervisorctl -c supervisor.conf start [all]|[appname]   启动指定/所有 supervisor 管理的程序进程</div><div class="line">supervisorctl -c supervisor.conf stop [all]|[appname]    关闭指定/所有 supervisor 管理的程序进程</div></pre></td></tr></table></figure></p>
<h3 id="后续会加入nginx的配置，但是我还没有自己理清楚，未完待续。。。"><a href="#后续会加入nginx的配置，但是我还没有自己理清楚，未完待续。。。" class="headerlink" title="后续会加入nginx的配置，但是我还没有自己理清楚，未完待续。。。"></a>后续会加入nginx的配置，但是我还没有自己理清楚，未完待续。。。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;已经搭建好了一个Flask应用，当前启动方式是&lt;code&gt;gunicorn -b 0.0.0.0:8000 wsgi:application&lt;/code&gt;,但是每次部署的时候都需要先&lt;code&gt;cat router.pid&lt;/code&gt;，然后&lt;code&gt;kill&lt;/code
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Flask API 序列化和反序列化</title>
    <link href="http://yoursite.com/2017/01/03/Flask-API-%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://yoursite.com/2017/01/03/Flask-API-序列化和反序列化/</id>
    <published>2017-01-03T00:33:14.000Z</published>
    <updated>2017-01-20T05:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是2016的最后一天，顺便整理了一下手头的资料，看到Flask中关于字符串处理当时踩得坑，反思的同时也对接口处理的序列化和反序列化有了较深的体会。</p>
<h3 id="前期"><a href="#前期" class="headerlink" title="前期"></a>前期</h3><p>我觉得我做事可能上手的确很快，比如当时写<code>API</code>时，刚存入<code>sqlite</code>中存入类型是以<code>string</code>形式存入，以<code>GET</code>接口展示时候，以<code>return json.loads()</code>，其实对这样操作一直很懵懂，现在谈谈自己的理解：</p>
<blockquote>
<p>当时，我需要以字符串形式存入，其实是序列化过程，把python的对象编码转换为json格式的字符串，而展示的时候，其实是反序列化过程，把json格式字符串解码为python数据对象。在python的标准库中，专门提供了json处理这部分。</p>
</blockquote>
<p>先看看json的方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line"></div><div class="line">import json</div><div class="line"></div><div class="line">print dir(json)</div><div class="line">print json.__all__</div></pre></td></tr></table></figure>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[&apos;dump&apos;, &apos;dumps&apos;, &apos;load&apos;, &apos;loads&apos;, &apos;JSONDecoder&apos;, &apos;JSONEncoder&apos;]</div></pre></td></tr></table></figure></p>
<h3 id="进入正题"><a href="#进入正题" class="headerlink" title="进入正题"></a>进入正题</h3><p>我们定义一个字典，通过json把它序列化为json格式的字符串，见实现的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line">import  json</div><div class="line">dict1=&#123;&apos;name&apos;:&apos;diaojunxian&apos;,&apos;age&apos;:22,&apos;address&apos;:&apos;xian&apos;&#125;</div><div class="line">print u&apos;未序列化前的数据类型为:&apos;,type(dict1)</div><div class="line">print u&apos;未序列化前的数据:&apos;,dict1</div><div class="line">#对dict1进行序列化的处理</div><div class="line">str1=json.dumps(dict1)</div><div class="line">print u&apos;序列化后的数据类型为:&apos;,type(str1)</div><div class="line">print u&apos;序列化后的数据为:&apos;,str1</div></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">未序列化前的数据类型为: &lt;type &apos;dict&apos;&gt;</div><div class="line">未序列化前的数据: &#123;&apos;age&apos;: 22, &apos;name&apos;: &apos;diaojunxian&apos;, &apos;address&apos;: &apos;xian&apos;&#125;</div><div class="line">序列化后的数据类型为: &lt;type &apos;str&apos;&gt;</div><div class="line">序列化后的数据为: &#123;&quot;age&quot;: 22, &quot;name&quot;: &quot;diaojunxian&quot;, &quot;address&quot;: &quot;xian&quot;&#125;</div></pre></td></tr></table></figure></p>
<p>通过如上的代码以及结果可以看到，这就是一个序列化的过程，简单的说就是把python的数据类型转换为json格式的字符串。下来我们再反序列化，把json格式的字符串解码为python的数据对象，见实现的代码和输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#对str1反序列化</div><div class="line">dict2=json.loads(str1)</div><div class="line">print u&apos;反序列化后的数据类型:&apos;,type(dict2)</div><div class="line">print u&apos;反序列化后的数据：&apos;,dict2</div></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">反序列化后的数据类型: &lt;type &apos;dict&apos;&gt;</div><div class="line">反序列化后的数据： &#123;u&apos;age&apos;: 22, u&apos;name&apos;: u&apos;diaojunxian&apos;, u&apos;address&apos;: u&apos;xian&apos;&#125;</div></pre></td></tr></table></figure></p>
<h3 id="中文处理"><a href="#中文处理" class="headerlink" title="中文处理"></a>中文处理</h3><p>在编程过程还发现一个问题，在序列化时，中文汉字总是被转换为unicode码，在dumps函数中添加参数ensure_ascii=False即可解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">#coding=utf-8</div><div class="line">import json;  </div><div class="line">  </div><div class="line">#原始json数据  </div><div class="line">jsonData=[&#123;&apos;name&apos;:&apos;刁俊先&apos;,&apos;age&apos;:30,&apos;sex&apos;:&apos;男&apos;&#125;,&#123;&apos;name&apos;:&apos;文静&apos;,&apos;age&apos;:20,&apos;sex&apos;:&apos;女&apos;&#125;];  </div><div class="line">  </div><div class="line">#序列化，然后输出  </div><div class="line">jsonStr=json.dumps(jsonData,ensure_ascii=False);  </div><div class="line">print(&quot;序列化结果：&quot;);  </div><div class="line">print(jsonStr);  </div><div class="line">  </div><div class="line">#再将jsonStr反序列化为json格式  </div><div class="line">jsonData=json.loads(jsonStr, strict=False);  </div><div class="line">print(&quot;反序列化整体结果：&quot;);  </div><div class="line">print(jsonData);  </div><div class="line">#然后接口返回为</div><div class="line">print json.dumps(jsonData, ensure_ascii=False, indent=4)</div></pre></td></tr></table></figure></p>
<p>输出内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">序列化结果：</div><div class="line">[&#123;&quot;age&quot;: 30, &quot;name&quot;: &quot;刁俊先&quot;, &quot;sex&quot;: &quot;男&quot;&#125;, &#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;文静&quot;, &quot;sex&quot;: &quot;女&quot;&#125;]</div><div class="line">反序列化整体结果：</div><div class="line">[&#123;u&apos;age&apos;: 30, u&apos;name&apos;: u&apos;\u5201\u4fca\u5148&apos;, u&apos;sex&apos;: u&apos;\u7537&apos;&#125;, &#123;u&apos;age&apos;: 20, u&apos;name&apos;: u&apos;\u6587\u9759&apos;, u&apos;sex&apos;: u&apos;\u5973&apos;&#125;]</div><div class="line">然后接口返回为：</div><div class="line">[</div><div class="line">    &#123;</div><div class="line">        &quot;age&quot;: 30, </div><div class="line">        &quot;name&quot;: &quot;刁俊先&quot;, </div><div class="line">        &quot;sex&quot;: &quot;男&quot;</div><div class="line">    &#125;, </div><div class="line">    &#123;</div><div class="line">        &quot;age&quot;: 20, </div><div class="line">        &quot;name&quot;: &quot;文静&quot;, </div><div class="line">        &quot;sex&quot;: &quot;女&quot;</div><div class="line">    &#125;</div><div class="line">]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天是2016的最后一天，顺便整理了一下手头的资料，看到Flask中关于字符串处理当时踩得坑，反思的同时也对接口处理的序列化和反序列化有了较深的体会。&lt;/p&gt;
&lt;h3 id=&quot;前期&quot;&gt;&lt;a href=&quot;#前期&quot; class=&quot;headerlink&quot; title=&quot;前期&quot;&gt;&lt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(十五)——BlueOcean</title>
    <link href="http://yoursite.com/2016/12/22/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%8D%81%E4%BA%94-%E2%80%94%E2%80%94BlueOcean/"/>
    <id>http://yoursite.com/2016/12/22/持续集成实施-十五-——BlueOcean/</id>
    <published>2016-12-22T01:30:27.000Z</published>
    <updated>2016-12-23T02:05:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>由于电脑系统更换过，本地安装的jenkins已经没有了，为了验证BlueOcean，决定重新安装jenkins。<br>之前一直用<code>brew install jenkins</code>，这次决定手动安装，通过war包和tomcat启动。</p>
<h4 id="一、配置Tomcat"><a href="#一、配置Tomcat" class="headerlink" title="一、配置Tomcat"></a>一、配置Tomcat</h4><p>1、下载很简单<br>登录Tomcat官网，地址是<a href="http://tomcat.apache.org，点击Download选择需要下载的版本下载，需要注意的是我的mac版本，故选择下载Core下面的zip。" target="_blank" rel="external">http://tomcat.apache.org，点击Download选择需要下载的版本下载，需要注意的是我的mac版本，故选择下载Core下面的zip。</a><br>2、解压和启动<br>我就解压在本地的Documents里面，然后重命名为jenkins。这时候<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd jenkins/bin</div><div class="line">sh ./starup.sh</div></pre></td></tr></table></figure></p>
<p>验证tomcat是否启动成功，一般情况下，会报错提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Cannot find ./catalina.sh</div><div class="line">The file is absent or does not have execute permission</div><div class="line">This file is needed to run this program</div></pre></td></tr></table></figure></p>
<p>是因为权限不够，赋予权限即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod 755 bin/*.sh</div></pre></td></tr></table></figure></p>
<p>这个时候，启动正常应该提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Using CATALINA_BASE:   /Users/djx/Documents/JENKINS</div><div class="line">Using CATALINA_HOME:   /Users/djx/Documents/JENKINS</div><div class="line">Using CATALINA_TMPDIR: /Users/djx/Documents/JENKINS/temp</div><div class="line">Using JRE_HOME:        /Library/Java/JavaVirtualMachines/jdk1.8.0_111.jdk/Contents/Home</div><div class="line">Using CLASSPATH:       /Users/djx/Documents/JENKINS/bin/bootstrap.jar:/Users/djx/Documents/JENKINS/bin/tomcat-juli.jar</div></pre></td></tr></table></figure></p>
<p>打开浏览器输入<code>http:127.0.0.1:8080</code>应该有tomcat的提示。</p>
<p>关闭tomcat也很简单:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sh ./shutdown.sh</div></pre></td></tr></table></figure></p>
<h4 id="二、下载jenkins-war并配置tomcat"><a href="#二、下载jenkins-war并配置tomcat" class="headerlink" title="二、下载jenkins.war并配置tomcat"></a>二、下载jenkins.war并配置tomcat</h4><p>1、下载jenkins<br>下载安装jenkins，去官网下载<code>https://jenkins.io/</code><br>这里直接下载war包, 不要下载Mac OS X,下载完成的到jenkins.war文件<br>2、安装，启动jenkins<br>将jenkins.war文件复制到jenkins/webapps,然后删除ROOT文件, 重命名jenkins.war -&gt; ROOT.war</p>
<p>3、bin 目录下新建 setenv.sh 文件，内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">export JENKINS_HOME=/Users/djx/Documents/jenkins_workspace</div></pre></td></tr></table></figure></p>
<p>这里路径随意，是存放job等一些信息的。</p>
<p>4、启动，依然是用<code>sh ./starup.sh</code><br>5、然后就可以在浏览器输入<code>http:127.0.0.1:8080</code>，进入jenkins。</p>
<p>6、查看日志输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tail -f ../logs/catalina.out</div></pre></td></tr></table></figure></p>
<h4 id="三、BlueOcean"><a href="#三、BlueOcean" class="headerlink" title="三、BlueOcean"></a>三、BlueOcean</h4><p>1、了解BlueOcean是什么之前，我谈谈做持续集成这么久之后，想达到新目标：</p>
<hr>
<p>提取出公有部分封装为公有JOB<br>实现pipeline对其他JOB的调用和逻辑的判断<br>实现多节点同时并发build</p>
<hr>
<p>好了，目前BlueOcean貌似支持，虽然只是以插件形式存在，需要Jenkins 2.7版本以上才支持，我就是用brew install jenkins安装的jenkins怎么都无法安装上BlueOcean，所以我采用tomacat加jenkins.war来实现安装。</p>
<p>2、安装<br>系统管理-&gt;管理插件-&gt;可选插件，选择BlueOcean beta-&gt;restart。</p>
<p>安装完毕后，BlueOcean入口在菜单栏居中: “Open Blue Ocean”，进去后可以看到全新的UI：<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/blueocean01.png" alt="Blue Ocean进入界面"></p>
<p>3、开始尝试<br>(1)新建一个Pipeline项目，配置如下：<br>选择Pipeline script：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/env groovy</div><div class="line"></div><div class="line">node &#123;</div><div class="line">   stage(&apos;Clone Code&apos;) &#123; // for display purposes</div><div class="line">      git branch: &apos;master&apos;, credentialsId: &apos;xxx&apos;, url: &apos;ssh://xxxx@internal.ddd.com.cn:xxx&apos;</div><div class="line"></div><div class="line">   &#125;</div><div class="line">   stage(&apos;build&apos;) &#123;</div><div class="line">       sh &quot;ci_ios/xcode-build/ipa-inhouse/mifit-inhouse-upgrade.sh&quot;</div><div class="line">       </div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(2)可以看构建流程:<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/blueocean02.png" alt="Blue Ocean构建流程"></p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>现在只是一个beta版本，社区还不活跃，比如还不会同时拉取两个repo，比如还不会解决参数化。<br>慢慢来吧，这是一个过程，但是必须经历。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于电脑系统更换过，本地安装的jenkins已经没有了，为了验证BlueOcean，决定重新安装jenkins。&lt;br&gt;之前一直用&lt;code&gt;brew install jenkins&lt;/code&gt;，这次决定手动安装，通过war包和tomcat启动。&lt;/p&gt;
&lt;h4 id=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(十四)——Xcode Server配置(二)</title>
    <link href="http://yoursite.com/2016/12/12/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%8D%81%E5%9B%9B-%E2%80%94%E2%80%94Xcode-Server%E9%85%8D%E7%BD%AE-%E4%BA%8C/"/>
    <id>http://yoursite.com/2016/12/12/持续集成实施-十四-——Xcode-Server配置-二/</id>
    <published>2016-12-12T08:17:23.000Z</published>
    <updated>2016-12-12T08:30:26.000Z</updated>
    
    <content type="html"><![CDATA[<p>前文介绍过Xcode Server配置，本文介绍Xcode Server和Jenkins Gerrit trigger集成。</p>
<h3 id="1、Jenkins-Gerrit-trigger配置"><a href="#1、Jenkins-Gerrit-trigger配置" class="headerlink" title="1、Jenkins Gerrit trigger配置"></a>1、Jenkins Gerrit trigger配置</h3><p>这里是在jenkins内配置Gerrit trigger，注意主要是为了Trigger job然后向xcode server 发起请求，让Xcode server开始构建，因而需要取消Jenkins trigger内的Verify+1和Verify-1操作。<br>触发Xcode server借助Xcode server官方Api。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export</div><div class="line">bot_id=&quot;8941fe179c67939ab009907baa64e3cf&quot;</div><div class="line">curl -k -X POST https://10.8.2.53:20343/api/bots/$&#123;bot_id&#125;/integrations</div></pre></td></tr></table></figure></p>
<h3 id="2、Xcode-Server内设置"><a href="#2、Xcode-Server内设置" class="headerlink" title="2、Xcode Server内设置"></a>2、Xcode Server内设置</h3><p>在Trigger内触发Xcode Server job之后，然后在bots内新建Pre-Integration Scripts and Post-Integration Scripts，是为了更新gerrit 当前commits，并且依据运行结果，进行Verify+1和Verify-1。<br>Pre-Integration Scripts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">project_path=$(pwd)</div><div class="line">cd $&#123;project_path&#125;</div><div class="line"></div><div class="line">ssh -p 29418 xxx@xxx &apos;gerrit query label:Verified=0 project:&quot;xxx&quot;  status: open limit:1 --current-patch-set&apos; &gt;~/Desktop/junk.txt</div><div class="line">export commit=`grep revision: ~/Desktop/junk.txt | grep -oE &apos;[^ ]+$&apos;`</div><div class="line">export ref=`grep ref: ~/Desktop/junk.txt | grep -oE &apos;[^ ]+$&apos;`</div><div class="line">git fetch &quot;ssh://xx@xxx:29418/xxx&quot; $ref &amp;&amp; git checkout FETCH_HEAD</div><div class="line">git checkout -b $commit</div><div class="line"></div><div class="line">ssh -p 29418 xx@xx  &apos;gerrit review -p &quot;xx&quot; -m &quot;Xcode Server Starting Test&quot; &apos;$commit</div></pre></td></tr></table></figure></p>
<p>Post-Integration Scripts<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">project_path=$(pwd)</div><div class="line">cd $&#123;project_path&#125;</div><div class="line"></div><div class="line">export commit=`grep revision: ~/Desktop/junk.txt | grep -oE &apos;[^ ]+$&apos;`</div><div class="line">ssh -p 29418 xx@xx &apos;gerrit review -p &quot;testing/dummy&quot; -m &quot;Test from the script&quot; --verified +1 &apos;$commit</div></pre></td></tr></table></figure></p>
<p>这就实现了Jenkins触发，然后Xcode server构建，结果反馈gerrit。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前文介绍过Xcode Server配置，本文介绍Xcode Server和Jenkins Gerrit trigger集成。&lt;/p&gt;
&lt;h3 id=&quot;1、Jenkins-Gerrit-trigger配置&quot;&gt;&lt;a href=&quot;#1、Jenkins-Gerrit-trigger
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(十三)——Infer</title>
    <link href="http://yoursite.com/2016/12/09/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%8D%81%E4%B8%89-%E2%80%94%E2%80%94Infer/"/>
    <id>http://yoursite.com/2016/12/09/持续集成实施-十三-——Infer/</id>
    <published>2016-12-09T06:18:52.000Z</published>
    <updated>2016-12-09T06:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>Infer是一个静态代码分析工具，facebook出品，可以分析OC，Java和C代码，报告潜在的问题。<br>Infer在github上地址：<a href="https://github.com/facebook/infer。" target="_blank" rel="external">https://github.com/facebook/infer。</a><br>当前我配置了MAC环境并检查iOS提交的代码，看效果如何。</p>
<hr>
<h3 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h3><p>Infer为Linux和MacOS系统提供了预构建的二进制文件,如果你只是想使用Infer,而不想为该项目贡献代码的话,这些二进制文件足够了.相反，如果你想编译infer,请选择源码安装。此文档以Mac系统，源文件安装为栗子。</p>
<p>环境要求</p>
<p>Python版本：大于等于2.7</p>
<p>第一种：二进制文件安装</p>
<p>从infer release页面获取最新版本infer-osx-vXX.tar.xz (以osx标识),然后执行下面命令来安装Infer.</p>
<p>第二种：源码安装</p>
<p>借助brew安装</p>
<p>1.1安装brew<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/ruby -e “$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)”</div></pre></td></tr></table></figure></p>
<p>1.2安装infer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">brew install infer</div></pre></td></tr></table></figure></p>
<p>安装达到100% 后可通过｀infer –version｀查看infer版本信息。</p>
<h3 id="二、Infer-运行的两个阶段"><a href="#二、Infer-运行的两个阶段" class="headerlink" title="二、Infer 运行的两个阶段"></a>二、Infer 运行的两个阶段</h3><p>不管是分析哪种语言，Infer 运行时，分为两个主要阶段：</p>
<ol>
<li><p>捕获阶段<br>Infer 捕获编译命令，将文件翻译成 Infer 内部的中间语言。<br>这种翻译和编译类似，Infer 从编译过程获取信息，并进行翻译。这就是我们调用 Infer 时带上一个编译命令的原因了，比如: infer – clang -c file.c, infer – javac File.java。结果就是文件照常编译，同时被 Infer 翻译成中间语言，留作第二阶段处理。特别注意的就是，如果没有文件被编译，那么也没有任何文件会被分析。<br>Infer 把中间文件存储在结果文件夹中，一般来说，这个文件夹会在运行 infer 的目录下创建，命名是 infer-out/。当然，你也可以通过 -o 选项来自定义文件夹名字：<br>infer -o /tmp/out – javac Test.java</p>
</li>
<li><p>分析阶段<br>在分析阶段，Infer 分析 infer-out/ 下的所有文件。分析时，会单独分析每个方法和函数。<br>在分析一个函数的时候，如果发现错误，将会停止分析，但这不影响其他函数的继续分析。<br>所以你在检查问题的时候，修复输出的错误之后，需要继续运行 Infer 进行检查，知道确认所有问题都已经修复。<br>错误除了会显示在标准输出之外，还会输出到文件 infer-out/bug.txt 中，我们过滤这些问题，仅显示最有可能存在的。<br>在结果文件夹中（infer-out），同时还有一个 csv 文件 report.csv，这里包含了所有 Infer 产生的信息，包括：错误，警告和信息。</p>
</li>
</ol>
<p><strong>增量模式和非增量模式</strong><br>运行时，Infer 默认会删除之前产生的 infer-out/ 文件夹，这会导致非增量模式。</p>
<p>如果需要增量模式，加入 –incremental（或者 -i）参数运行，这样 infer-out/ 文件夹将不会被删除。</p>
<p>也有例外的情况，尤其是你只能在上面的一个阶段使用这个参数。</p>
<p>比如， infer – javac Hello.java 相当于运行了以下两个命令。</p>
<p>infer -a capture – javac Hello.java<br>infer – analyze</p>
<p>注意，第二个命令不会删除 infer-out/，因为分析阶段，需要使用文件夹中的进行分析。</p>
<p>你可以通过 infer –help 了解更多关于 Infer 的各种操作模式。</p>
<p>下面我们简单明了地强调一下，什么情况下需要使用增量模式，什么时候使用非增量模式。</p>
<p>2.1非增量模式</p>
<p>非增量模式适用于单编译命令，重复运行 Infer 检测的情况。</p>
<p>infer – javac Hello.java<br>edit Hello.java</p>
<h1 id="编译-Hello-java，改动了代码，比如修复了一些问题"><a href="#编译-Hello-java，改动了代码，比如修复了一些问题" class="headerlink" title="编译 Hello.java，改动了代码，比如修复了一些问题"></a>编译 Hello.java，改动了代码，比如修复了一些问题</h1><p>infer – javac Hello.java</p>
<p>如果需要进行全新的一轮的分析，必须：<br>    删除结果文件夹：<br>    rm -fr infer-out<br>    删除构建产物。比如，对于基于 make 的项目，运行 make clean。</p>
<p>2.2增量模式</p>
<p>如果想使用 Infer 进行增量分析，你的编译系统需要是这其中的一个。<br>运行 Infer 进行检测的时候，只需要简单运行 infer – &lt;编译命令&gt;，其中编译命令就是我们平时编译的命令。需要注意的是，运行前的项目是清理过的，这样 Infer 才能在捕获阶段捕获所有的编译命令。<br>比如，一个 gradle 项目：</p>
<p>gradle clean<br>infer – gradle build</p>
<p>接下来，如果你修改了项目中的一些文件，你可以重复上面的命令，清理并重新分析整个项目。或者通过参数，让 Infer 使用使用增量模式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">edit some/File.java</div><div class="line"># 修改了 some/File.java 的一些内容。</div><div class="line">infer --incremental -- gradle build</div></pre></td></tr></table></figure></p>
<p>当然，你也可以在第一次运行 Infer 进行检测的时候，就使用 –incremental。</p>
<h3 id="三、本项目配置使用"><a href="#三、本项目配置使用" class="headerlink" title="三、本项目配置使用"></a>三、本项目配置使用</h3><p>文前就声明本文只是配置MAC环境，故而使用命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">infer --pod-xml -- xcodebuild -workspace MiFit.xcworkspace -scheme MiFit -configuration Release -sdk iphonesimulator clean build</div></pre></td></tr></table></figure></p>
<h3 id="配置过程中出现问题"><a href="#配置过程中出现问题" class="headerlink" title="配置过程中出现问题"></a>配置过程中出现问题</h3><p>1、一直提示<code>ERROR: &quot;etree&quot; Python package not found.</code><br>解决：<code>sudo pip install lxml</code></p>
<hr>
<p>当前先使用iOS做测试。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Infer是一个静态代码分析工具，facebook出品，可以分析OC，Java和C代码，报告潜在的问题。&lt;br&gt;Infer在github上地址：&lt;a href=&quot;https://github.com/facebook/infer。&quot; target=&quot;_blank&quot; rel=
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(十二)——Xcode Server配置</title>
    <link href="http://yoursite.com/2016/12/01/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%8D%81%E4%BA%8C-%E2%80%94%E2%80%94Xcode-Server%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2016/12/01/持续集成实施-十二-——Xcode-Server配置/</id>
    <published>2016-12-01T00:33:55.000Z</published>
    <updated>2016-12-01T01:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成测试工具在mac中有使用较为频繁的Xcode Server服务器，它号称集成了git版本管理和持续集成服务，而且还有文档管理的功能。如下图所示：<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server01.png" alt="Xcode Server工作架构"></p>
<p>下面简单描述一下配置过程，当然很多细节还在具体摸索过程中，当前只是跑通了mac客户端和mac Xcode Server服务端。</p>
<hr>
<h3 id="一、配置Xcode-Server服务器"><a href="#一、配置Xcode-Server服务器" class="headerlink" title="一、配置Xcode Server服务器"></a>一、配置Xcode Server服务器</h3><p>1、apple给开发者可以凭开发者账号免费兑换os x server。免费兑换地址</p>
<p><a href="https://developer.apple.com/osx/download/" target="_blank" rel="external">https://developer.apple.com/osx/download/</a></p>
<p>2、下载os x server后点击安装。</p>
<p>3、打开 Server 应用，以查看 OS X Server 中提供的服务列表。选择“Xcode”。</p>
<p>点按“选取 Xcode”按钮，然后在“应用程序”文件夹中选择“Xcode”。Xcode 服务将自动启动。</p>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server02.png" alt="Xcode Server启动服务"></p>
<h3 id="二、配置Xcode客户端"><a href="#二、配置Xcode客户端" class="headerlink" title="二、配置Xcode客户端"></a>二、配置Xcode客户端</h3><p>1、打开客户端上的xcode然后，选择 XCode 的Preferences，然后选择“Accounts”，在底端点击加号按钮，选择“Add Server”。效果如图所示:<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server03.png" alt="Xcode客户端"></p>
<p>2、打开xcode&gt;product&gt;create bot</p>
<p>3、填写bot名称，选择Xcode Server服务器<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server04.png" alt="Xcode Bot配置"></p>
<p>4、Actions：选择执行的动作</p>
<p>   a、对代码进行静态分析</p>
<p>   b、对代码进行单元测试</p>
<p>   c、生成archive包（可以选择是否生成用户安装包）</p>
<p>5、cleaning：选择在何时清理项目，有几个选项（总是、每天、每周、从不）</p>
<p>6、configuration：选择编译配置（Debug、release）</p>
<p>7、选择在何时Xcode Server服务器开始持续集成，有几个选项（定时、在有新代码提交时、手动）</p>
<p>8、Before Integration 在开始持续集成前执行的脚本</p>
<p>9、 After Integration在持续集成后执行的脚本</p>
<h3 id="三、Xcode-Server服务器证书配置"><a href="#三、Xcode-Server服务器证书配置" class="headerlink" title="三、Xcode Server服务器证书配置"></a>三、Xcode Server服务器证书配置</h3><p>需要注意的是iOS最变态的就是证书管理了，这里也同样如此需要注意证书的配置。<br>1、配置Certificates</p>
<ul>
<li><p>打开钥匙串，将iPhone Developer: xxx和iPhone Distribution:xxx导出为.p12文件</p>
</li>
<li><p>导入装OS X Server的MAC的钥匙串中，这次需导入到钥匙串系统中，而不是登录中，持续集成生成包时证书由/usr/bin/codesign管理，所以需将codesign添加为允许访问证书的程序，在显示简介中选择 访问控制 &gt;始终通过这些应用程序访问 中点击加号，开始选择/usr/bin/codesign程序。选择完成后点击确认。由于usr是隐藏文件，在选择时使用快捷键 CMD+SHIFT+. 显示隐藏文件</p>
</li>
</ul>
<p>2、将Provisioning Profiles拷贝到Xcode Server</p>
<ul>
<li><p>Xcode客户端描述文件保存在以下文件夹中User/Library/MobileDevice/ProvisioningProfiles</p>
</li>
<li><p>Xcode Server服务器描述文件保存在以下文件夹中 /Library/Developer/XcodeServer/ProvisioningProfiles，将Xcode客户端路径下的证书保存至Xcode Server服务器对应路径下</p>
</li>
</ul>
<h3 id="四、开始构建"><a href="#四、开始构建" class="headerlink" title="四、开始构建"></a>四、开始构建</h3><p>可以选择在客户端mac xcode内进行构建，或者mac xcode server内构建，若在xcode server内构建，并可以看到结果如图所示：<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server05.png" alt="Xcode Server构建"><br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server06.png" alt=""></p>
<h3 id="后续继续探索，记录以便整理。。。"><a href="#后续继续探索，记录以便整理。。。" class="headerlink" title="后续继续探索，记录以便整理。。。"></a>后续继续探索，记录以便整理。。。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续集成测试工具在mac中有使用较为频繁的Xcode Server服务器，它号称集成了git版本管理和持续集成服务，而且还有文档管理的功能。如下图所示：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/diaojunxian/d
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(十一)——新需求</title>
    <link href="http://yoursite.com/2016/11/28/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%8D%81%E4%B8%80-%E2%80%94%E2%80%94%E6%96%B0%E9%9C%80%E6%B1%82/"/>
    <id>http://yoursite.com/2016/11/28/持续集成实施-十一-——新需求/</id>
    <published>2016-11-28T06:55:44.000Z</published>
    <updated>2016-11-28T07:02:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>1、上周已经完成了北京米动同学，新的需求关于iOS打包inhouse和adhoc。本周有需要更改info.plist中文件里面dict内的字段的值，以CFBundleURLSchemes为例。<br>解决过程：<br>由于之前一直用的是<code>/usr/libexec/PlistBuddy</code>，但是之前用到的地方是修改bundleid，但是现在要更改的是在dict内，之前在string，很简单的过程，先使用<code>/usr/libexec/PlistBuddy -h</code>。注意到这里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Entry Format:</div><div class="line">    Entries consist of property key names delimited by colons.  Array items</div><div class="line">    are specified by a zero-based integer index.  Examples:</div><div class="line">        :CFBundleShortVersionString</div><div class="line">        :CFBundleDocumentTypes:2:CFBundleTypeExtensions</div></pre></td></tr></table></figure></p>
<p>原来dict内的字段修改需要这样改，那么解决方案随之而来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bundleURLSchemes=$(/usr/libexec/PlistBuddy -c &quot;print CFBundleURLTypes:0:CFBundleURLSchemes:0&quot; &quot;$&#123;project_infoplist_path&#125;&quot;)</div><div class="line">if [ &quot;$&#123;bundleURLSchemes&#125;&quot; != &quot;xxx&quot; ]; then</div><div class="line">	/usr/libexec/PlistBuddy -c &quot;set CFBundleURLTypes:0:CFBundleURLSchemes:0 &apos;xxx&apos;&quot; &quot;$&#123;project_infoplist_path&#125;&quot;</div><div class="line">fi;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、上周已经完成了北京米动同学，新的需求关于iOS打包inhouse和adhoc。本周有需要更改info.plist中文件里面dict内的字段的值，以CFBundleURLSchemes为例。&lt;br&gt;解决过程：&lt;br&gt;由于之前一直用的是&lt;code&gt;/usr/libexec/
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(十)——Oclint</title>
    <link href="http://yoursite.com/2016/11/17/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E2%80%94%E2%80%94Oclint/"/>
    <id>http://yoursite.com/2016/11/17/持续集成实施-——Oclint/</id>
    <published>2016-11-17T07:21:53.000Z</published>
    <updated>2016-11-17T07:29:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>OCLint是一个强大的静态代码分析工具，可以用来提高代码质量，查找潜在的bug，主要针对c,c++和Objective-c的静态分析。功能非常强大。<br>目前只是简单使用，浮于表面。。。。。</p>
<h3 id="1、oclint-与-xcpretty的安装"><a href="#1、oclint-与-xcpretty的安装" class="headerlink" title="1、oclint 与 xcpretty的安装"></a>1、oclint 与 xcpretty的安装</h3><p>推荐是用Homebrew 来安装，快速且节省精力，也可以选择源码安装或者release包来安装，不过需要配置环境变量的内容。使用Homebrew 安装时，需要先设置brew的第三方仓库，然后安装，xcpretty 用于解析xcodebuild 构建日志，解析后的结果交给oclint来使用：<br>oclint的安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">brew tap oclint/formulae</div><div class="line">brew install oclint</div></pre></td></tr></table></figure></p>
<p>xcpretty的安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install xcpretty</div></pre></td></tr></table></figure></p>
<h3 id="2、构建与静态代码扫描"><a href="#2、构建与静态代码扫描" class="headerlink" title="2、构建与静态代码扫描"></a>2、构建与静态代码扫描</h3><h4 id="1）、构建与解析日志"><a href="#1）、构建与解析日志" class="headerlink" title="1）、构建与解析日志"></a>1）、构建与解析日志</h4><p>我们使用xcodebuild 来构建。</p>
<p>xcodebuild 默认构建的格式Release ，需要构建Debug 或者 AdHoc 包自行添加相关参数来执行。build之后，使用xcpretty 来解析编译日志。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">CODE_SIGN_IDENTITY=&quot;xxx&quot;</div><div class="line"></div><div class="line">DEVELOPER_DIR=&quot;/Applications/Xcode7.app&quot; xcodebuild CODE_SIGN_IDENTITY=$&#123;CODE_SIGN_IDENTITY&#125; clean</div><div class="line"></div><div class="line">DEVELOPER_DIR=&quot;/Applications/Xcode7.app&quot; xcodebuild CODE_SIGN_IDENTITY=$&#123;CODE_SIGN_IDENTITY&#125; | xcpretty -r json-compilation-database</div><div class="line"></div><div class="line">cp build/reports/compilation_db.json compile_commands.json</div></pre></td></tr></table></figure></p>
<p>-r json-compilation-database 制定的数据的输出格式为json格式。输出的数据为build/reports/compilation_db.json</p>
<h4 id="2）、解析结果使用oclint做扫描"><a href="#2）、解析结果使用oclint做扫描" class="headerlink" title="2）、解析结果使用oclint做扫描"></a>2）、解析结果使用oclint做扫描</h4><p>使用oclint时需要将build/reports/compilation_db.json 重新命名为 compile_commands.json 并移动至当前目录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">oclint-json-compilation-database -e Pods -- -o=lint.xml -report-type=pmd -stats -max-priority-1=9999 -max-priority-2=9999 -max-priority-3=9999 </div><div class="line">-rc LONG_LINE=500 -rc LONG_VARIABLE_NAME=100</div></pre></td></tr></table></figure></p>
<p>将结果输出格式为pmd 格式，然后通过jenkins的pmd插件就可以做结果的展示了。</p>
<h4 id="3）、oclint其它参数"><a href="#3）、oclint其它参数" class="headerlink" title="3）、oclint其它参数"></a>3）、oclint其它参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">-e   Pods   去掉依赖的第三方库的扫描</div><div class="line"></div><div class="line">-- -rc=LONG_LINE=200  改变默认函数行数为100</div><div class="line"></div><div class="line">LINT_DISABLE_RULES=\&quot;-disable-rule=LongClass \\  </div><div class="line"></div><div class="line">            -disable-rule=LongLine \\  </div><div class="line"></div><div class="line">            -disable-rule=LongMethod \\  </div><div class="line"></div><div class="line">            -disable-rule=LongVariableName \\  </div><div class="line"></div><div class="line">            -disable-rule=ShortVariableName \\  </div><div class="line"></div><div class="line">            -disable-rule=HighNcssMethod \\  </div><div class="line"></div><div class="line">            -disable-rule=DeepNestedBlock \\  </div><div class="line"></div><div class="line">            -disable-rule=TooManyFields \\  </div><div class="line"></div><div class="line">            -disable-rule=TooManyMethods \\  </div><div class="line"></div><div class="line">            -disable-rule=TooManyParameters \\  </div><div class="line"></div><div class="line">            -disable-rule=IvarAssignmentOutsideAccessorsOrInit\&quot;</div></pre></td></tr></table></figure>
<p>命令行最后加入 $LINT_DISBALE_RULES 可以禁用某些不需要的规则</p>
<h3 id="3、中间出现的问题"><a href="#3、中间出现的问题" class="headerlink" title="3、中间出现的问题"></a>3、中间出现的问题</h3><h4 id="1）oclint-error-violations-exceed-threshold"><a href="#1）oclint-error-violations-exceed-threshold" class="headerlink" title="1）oclint: error: violations exceed threshold"></a>1）oclint: error: violations exceed threshold</h4><p>调研之后确认是我们的代码错误多，超过了阈值，所以调大了-max-priority-1=9999 -max-priority-2=9999 -max-priority-3=9999 </p>
<h4 id="2-出现了code-sign错误"><a href="#2-出现了code-sign错误" class="headerlink" title="2)出现了code sign错误"></a>2)出现了code sign错误</h4><p>在xcodebuild后面加上参数 CODE_SIGN_IDENTITY就行了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;OCLint是一个强大的静态代码分析工具，可以用来提高代码质量，查找潜在的bug，主要针对c,c++和Objective-c的静态分析。功能非常强大。&lt;br&gt;目前只是简单使用，浮于表面。。。。。&lt;/p&gt;
&lt;h3 id=&quot;1、oclint-与-xcpretty的安装&quot;&gt;&lt;a 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2016/11/15/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%B9%9D/"/>
    <id>http://yoursite.com/2016/11/15/持续集成实施-九/</id>
    <published>2016-11-15T09:21:03.000Z</published>
    <updated>2017-01-06T02:50:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成测试工具在mac中有使用较为频繁的Xcode Server服务器，它号称集成了git版本管理和持续集成服务，而且还有文档管理的功能。如下图所示：<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server01.png" alt="Xcode Server工作架构"></p>
<p>下面简单描述一下配置过程，当然很多细节还在具体摸索过程中，当前只是跑通了mac客户端和mac Xcode Server服务端。</p>
<hr>
<h3 id="一、配置Xcode-Server服务器"><a href="#一、配置Xcode-Server服务器" class="headerlink" title="一、配置Xcode Server服务器"></a>一、配置Xcode Server服务器</h3><p>1、apple给开发者可以凭开发者账号免费兑换os x server。免费兑换地址</p>
<p><a href="https://developer.apple.com/osx/download/" target="_blank" rel="external">https://developer.apple.com/osx/download/</a></p>
<p>2、下载os x server后点击安装。</p>
<p>3、打开 Server 应用，以查看 OS X Server 中提供的服务列表。选择“Xcode”。</p>
<p>点按“选取 Xcode”按钮，然后在“应用程序”文件夹中选择“Xcode”。Xcode 服务将自动启动。</p>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server02.png" alt="Xcode Server启动服务"></p>
<h3 id="二、配置Xcode客户端"><a href="#二、配置Xcode客户端" class="headerlink" title="二、配置Xcode客户端"></a>二、配置Xcode客户端</h3><p>1、打开客户端上的xcode然后，选择 XCode 的Preferences，然后选择“Accounts”，在底端点击加号按钮，选择“Add Server”。效果如图所示:<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server03.png" alt="Xcode客户端"></p>
<p>2、打开xcode&gt;product&gt;create bot</p>
<p>3、填写bot名称，选择Xcode Server服务器<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server04.png" alt="Xcode Bot配置"></p>
<p>4、Actions：选择执行的动作</p>
<p>   a、对代码进行静态分析</p>
<p>   b、对代码进行单元测试</p>
<p>   c、生成archive包（可以选择是否生成用户安装包）</p>
<p>5、cleaning：选择在何时清理项目，有几个选项（总是、每天、每周、从不）</p>
<p>6、configuration：选择编译配置（Debug、release）</p>
<p>7、选择在何时Xcode Server服务器开始持续集成，有几个选项（定时、在有新代码提交时、手动）</p>
<p>8、Before Integration 在开始持续集成前执行的脚本</p>
<p>9、 After Integration在持续集成后执行的脚本</p>
<h3 id="三、Xcode-Server服务器证书配置"><a href="#三、Xcode-Server服务器证书配置" class="headerlink" title="三、Xcode Server服务器证书配置"></a>三、Xcode Server服务器证书配置</h3><p>需要注意的是iOS最变态的就是证书管理了，这里也同样如此需要注意证书的配置。<br>1、配置Certificates</p>
<ul>
<li><p>打开钥匙串，将iPhone Developer: xxx和iPhone Distribution:xxx导出为.p12文件</p>
</li>
<li><p>导入装OS X Server的MAC的钥匙串中，这次需导入到钥匙串系统中，而不是登录中，持续集成生成包时证书由/usr/bin/codesign管理，所以需将codesign添加为允许访问证书的程序，在显示简介中选择 访问控制 &gt;始终通过这些应用程序访问 中点击加号，开始选择/usr/bin/codesign程序。选择完成后点击确认。由于usr是隐藏文件，在选择时使用快捷键 CMD+SHIFT+. 显示隐藏文件</p>
</li>
</ul>
<p>2、将Provisioning Profiles拷贝到Xcode Server</p>
<ul>
<li><p>Xcode客户端描述文件保存在以下文件夹中User/Library/MobileDevice/ProvisioningProfiles</p>
</li>
<li><p>Xcode Server服务器描述文件保存在以下文件夹中 /Library/Developer/XcodeServer/ProvisioningProfiles，将Xcode客户端路径下的证书保存至Xcode Server服务器对应路径下</p>
</li>
</ul>
<h3 id="四、开始构建"><a href="#四、开始构建" class="headerlink" title="四、开始构建"></a>四、开始构建</h3><p>可以选择在客户端mac xcode内进行构建，或者mac xcode server内构建，若在xcode server内构建，并可以看到结果如图所示：<br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server05.png" alt="Xcode Server构建"><br><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/xcode-server06.png" alt=""></p>
<h3 id="五、Jenkins-Gerrit-trigger配置"><a href="#五、Jenkins-Gerrit-trigger配置" class="headerlink" title="五、Jenkins Gerrit trigger配置"></a>五、Jenkins Gerrit trigger配置</h3><p>这里是在jenkins内配置Gerrit trigger，注意主要是为了Trigger job然后向xcode server 发起请求，让Xcode server开始构建，因而需要取消Jenkins trigger内的Verify+1和Verify-1操作。<br>触发Xcode server借助Xcode server官方Api。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">export</div><div class="line">bot_id=&quot;8941fe179c67939ab009907baa64e3cf&quot;</div><div class="line">curl -k -X POST https://10.8.2.53:20343/api/bots/$&#123;bot_id&#125;/integrations</div></pre></td></tr></table></figure>
<h3 id="六、Xcode-Server内设置"><a href="#六、Xcode-Server内设置" class="headerlink" title="六、Xcode Server内设置"></a>六、Xcode Server内设置</h3><p>在Trigger内触发Xcode Server job之后，然后在bots内新建Pre-Integration Scripts and Post-Integration Scripts，是为了更新gerrit 当前commits，并且依据运行结果，进行Verify+1和Verify-1。<br>Pre-Integration Scripts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">project_path=$(pwd)</div><div class="line">cd $&#123;project_path&#125;</div><div class="line"></div><div class="line">ssh -p 29418 xxx@xxx &apos;gerrit query label:Verified=0 project:&quot;xxx&quot;  status:</div><div class="line"> open limit:1 --current-patch-set&apos; &gt;~/Desktop/junk.txt</div><div class="line">export commit=`grep revision: ~/Desktop/junk.txt | grep -oE &apos;[^ ]+$&apos;`</div><div class="line">export ref=`grep ref: ~/Desktop/junk.txt | grep -oE &apos;[^ ]+$&apos;`</div><div class="line">git fetch &quot;ssh://xx@xxx:29418/xxx&quot; $ref &amp;&amp; git checkout FETCH_HEAD</div><div class="line">git checkout -b $commit</div><div class="line"></div><div class="line">ssh -p 29418 xx@xx  &apos;gerrit review -p &quot;xx&quot; -m &quot;Xcode Server Starting Test&quot; &apos;$commit</div></pre></td></tr></table></figure>
<p>Post-Integration Scripts</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">project_path=$(pwd)</div><div class="line">cd $&#123;project_path&#125;</div><div class="line"></div><div class="line">export commit=`grep revision: ~/Desktop/junk.txt | grep -oE &apos;[^ ]+$&apos;`</div><div class="line">ssh -p 29418 xx@xx &apos;gerrit review -p &quot;testing/dummy&quot; -m &quot;Test from the script&quot; </div><div class="line">--verified +1 &apos;$commit</div></pre></td></tr></table></figure>
<p>这就实现了Jenkins触发，然后Xcode server构建，结果反馈gerrit。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续集成测试工具在mac中有使用较为频繁的Xcode Server服务器，它号称集成了git版本管理和持续集成服务，而且还有文档管理的功能。如下图所示：&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/diaojunxian/d
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(八)</title>
    <link href="http://yoursite.com/2016/11/04/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%85%AB/"/>
    <id>http://yoursite.com/2016/11/04/持续集成实施-八/</id>
    <published>2016-11-04T07:25:24.000Z</published>
    <updated>2016-11-18T09:30:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>上接遇到的奇怪需求和其他问题。。。。。</p>
<hr>
<h3 id="7、优化预警提醒"><a href="#7、优化预警提醒" class="headerlink" title="7、优化预警提醒"></a>7、优化预警提醒</h3><p>需求：其实需求也是蛮简单的需要告警信息更加及时可靠，之前的折中方案是，将console output log全部通过邮件推送到我个人邮箱，但是还是显得不及时，因为邮件浏览非常不及时，现在我们的交流工具主要是slack，故而集成到slack即好。<br>解决方案：借助requests auth获取jenkins console output log，借助slack web api推送到个人或者channel，借助jenkins插件<code>Execute a set of scripts</code>在job执行出错时候，预警。<br>看脚本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#获取jenkins output log</div><div class="line">def get_content(job_url):</div><div class="line">    &quot;&quot;&quot;取出console log全部内容&quot;&quot;&quot;</div><div class="line">    url = job_url + &quot;consoleText/api/json&quot;</div><div class="line">    headers = &#123;</div><div class="line">    	&quot;Content-Type&quot;: &quot;application/json&quot;,</div><div class="line">    	&quot;Accept&quot;: &quot;application/json&quot;</div><div class="line">    &#125;</div><div class="line">    response = requests.get(url, auth=(&quot;xxxx&quot;, &quot;xxxxx&quot;))</div><div class="line">    assert response.status_code == requests.codes.ok</div><div class="line">    return response.content</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#借助slack推送个人或者channel</div><div class="line">slack web api地址：https://api.slack.com/methods/chat.postMessage</div><div class="line">slack = Slacker(api_token, 100)</div><div class="line">slack.chat.post_message(userid, text=text, attachments=data)</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">添加execute a set of scripts并且勾选Execute script only if builds fails</div></pre></td></tr></table></figure>
<h3 id="8、同时存在xcode7和xcode8的时候有报错"><a href="#8、同时存在xcode7和xcode8的时候有报错" class="headerlink" title="8、同时存在xcode7和xcode8的时候有报错"></a>8、同时存在xcode7和xcode8的时候有报错</h3><p>报错为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">CoreSimulator is attempting to unload a stale CoreSimulatorService job.  Detected Xcode.app relocation or CoreSimulatorService version change.  Framework path (/</div><div class="line">Applications/Xcode.app/Contents/Developer/Library/PrivateFrameworks/CoreSimulator.framework) and version (303.8) does not match existing job path (/Applications</div><div class="line">/Xcode7.app/Contents/Developer/Library/PrivateFrameworks/CoreSimulator.framework/Versions/A/XPCServices/com.apple.CoreSimulator.CoreSimulatorService.xpc) and version </div><div class="line">(209.19).</div></pre></td></tr></table></figure></p>
<p>解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">launchctl remove com.apple.CoreSimulator.CoreSimulatorService || true</div></pre></td></tr></table></figure></p>
<h3 id="9、一直选择不到scheme"><a href="#9、一直选择不到scheme" class="headerlink" title="9、一直选择不到scheme"></a>9、一直选择不到scheme</h3><p>现象就是一直报错的提示是选择不到scheme<br>解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Choose Scheme &gt; Manage Schemes (from the Product Menu).</div><div class="line">Ensure the &apos;Shared&apos; box is checked for that scheme</div><div class="line">A new .xcscheme file has been created in your project at</div><div class="line">WorkspaceName.xcworkspace/xcshareddata/xcschemes.</div><div class="line">Commit this file to your repository</div></pre></td></tr></table></figure></p>
<h3 id="10、解决了bash-shell-session-update-command-not-found"><a href="#10、解决了bash-shell-session-update-command-not-found" class="headerlink" title="10、解决了bash: shell_session_update: command not found"></a>10、解决了<code>bash: shell_session_update: command not found</code></h3><p>解决方法很简单<code>rvm get head</code>。<br>真想说脏话。。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上接遇到的奇怪需求和其他问题。。。。。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;7、优化预警提醒&quot;&gt;&lt;a href=&quot;#7、优化预警提醒&quot; class=&quot;headerlink&quot; title=&quot;7、优化预警提醒&quot;&gt;&lt;/a&gt;7、优化预警提醒&lt;/h3&gt;&lt;p&gt;需求：其实需求也是蛮简单的需
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(七)</title>
    <link href="http://yoursite.com/2016/10/21/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%B8%83/"/>
    <id>http://yoursite.com/2016/10/21/持续集成实施-七/</id>
    <published>2016-10-21T03:40:42.000Z</published>
    <updated>2016-10-31T12:23:09.000Z</updated>
    
    <content type="html"><![CDATA[<p>从此贴开始整理工作中遇到的奇怪需求和奇怪问题。。。。</p>
<hr>
<h3 id="1、同时出adhoc和appstore包"><a href="#1、同时出adhoc和appstore包" class="headerlink" title="1、同时出adhoc和appstore包"></a>1、同时出adhoc和appstore包</h3><p>需求：满足发布iOS版本的时候同时出adhoc和appstore包<br>解决：使用gym出archive版本，然后用两种exoptionplist同时出ipa包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DEVELOPER_DIR=&quot;/Applications/Xcode.app&quot; xcodebuild -exportArchive </div><div class="line">-archivePath $&#123;archive_path&#125; </div><div class="line">-exportPath $&#123;ipa_name_adhoc&#125; </div><div class="line">-exportOptionsPlist $&#123;ExoptionPlist_adhoc&#125;</div></pre></td></tr></table></figure></p>
<p>遇到问题：appstore包可以正常出，但是adhoc包出不来failed，报错提示为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DEDistribution: Step failed: &lt;IDEDistributionThinningStep: 0x7fda446c5d90&gt;:</div><div class="line">Error Domain=IDEDistributionErrorDomain Code=14 &quot;No applicable devices found.&quot; </div><div class="line">UserInfo=0x7fda44b61b80 &#123;NSLocalizedDescription=No applicable devices found.&#125;</div><div class="line">error: exportArchive: No applicable devices found.</div></pre></td></tr></table></figure></p>
<p>问题解决：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem install CFPropertyList</div><div class="line">rvm use system</div></pre></td></tr></table></figure></p>
<p>期间可能会遇到fastlane命令失效的情况，重装fastlane即可。注意<code>rvm use system</code>之前需要通过<code>rvm list</code>验证一下，如果有多个ruby版本可以删除不需要的版本，通过<code>sudo remove ruby xxxx</code>进行。</p>
<hr>
<h3 id="2、优化git-parameter同步分支和TAG速度"><a href="#2、优化git-parameter同步分支和TAG速度" class="headerlink" title="2、优化git parameter同步分支和TAG速度"></a>2、优化git parameter同步分支和TAG速度</h3><p>需求：使用git parameter同步分支和TAG速度太慢，而且最重要的是git parameter不支持Multiple SCMs来拉取代码。<br>解决：使用插件Dynamic Choice Parameter，并加入groovy脚本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">#!/usr/bin/groovy</div><div class="line">def gettags = (&quot;git ls-remote -h 【git repo地址】&quot;).execute()</div><div class="line">text = gettags.in.text.readLines()</div><div class="line">branch = text.collect&#123;it.split()[1]&#125;</div><div class="line">//这里的branch可以随意匹配，我这里是为了只取branch，去掉包含sandbox分支</div><div class="line">branch_text = branch.grep(~/refs\/heads.*/).grep(~/^((?!(sandbox)).)*$/)</div><div class="line">.collect&#123;el-&gt;el.replaceAll(&quot;refs/heads/&quot;, &quot;&quot;)&#125;</div><div class="line">branch_text.unique()</div></pre></td></tr></table></figure></p>
<p>遇到问题：对groovy的正则匹配使用不熟悉，感觉groovy作为脚本语言，的确使用上更加便捷，对于groovy的语法，可以参考<a href="https://my.oschina.net/wstone/blog/389449。" target="_blank" rel="external">https://my.oschina.net/wstone/blog/389449。</a></p>
<hr>
<h3 id="3、jenkins执行ruby-v和slave上执行ruby-v版本不一致"><a href="#3、jenkins执行ruby-v和slave上执行ruby-v版本不一致" class="headerlink" title="3、jenkins执行ruby -v和slave上执行ruby -v版本不一致"></a>3、jenkins执行ruby -v和slave上执行ruby -v版本不一致</h3><p>问题：jenkins上执行pilot upload -d一直提示没有这个参数，但是本地执行却没有报错。<br>分析：出现的原因可能是之前执行过一句话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm use system</div></pre></td></tr></table></figure></p>
<p>现象是jenkins执行ruby -v是2.2.0版本，然后我在slave上执行rvm list，看不到ruby 2.2.0的版本，只交代最后的解决的过程，其他不表了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">只要在执行slave上打包命令之前加上</div><div class="line">#!/bin/bash -xl</div></pre></td></tr></table></figure></p>
<h3 id="4、jenkins执行gradlew打包，虽然BUILD-FAILED，但是结果仍然是SUCCESS"><a href="#4、jenkins执行gradlew打包，虽然BUILD-FAILED，但是结果仍然是SUCCESS" class="headerlink" title="4、jenkins执行gradlew打包，虽然BUILD FAILED，但是结果仍然是SUCCESS"></a>4、jenkins执行gradlew打包，虽然BUILD FAILED，但是结果仍然是SUCCESS</h3><p>需求：在构建任务过程中，如若出现BUILD FAILED，则告知打包是失败的。<br>解决：使用插件Jenkins Text Finder<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">勾选Also serach the console output</div><div class="line">Regular expression 填写BUILD FAILED</div></pre></td></tr></table></figure></p>
<p>这样就能把构建失败的结果告知出来。</p>
<hr>
<h3 id="5、在使用python-flask模块过程中，已经安装了flask库的情况下，依然有报错"><a href="#5、在使用python-flask模块过程中，已经安装了flask库的情况下，依然有报错" class="headerlink" title="5、在使用python flask模块过程中，已经安装了flask库的情况下，依然有报错"></a>5、在使用python flask模块过程中，已经安装了flask库的情况下，依然有报错</h3><p>报错提示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;test.py&quot;, line 1, in &lt;module&gt;</div><div class="line">    from flask import Flask</div><div class="line">  File &quot;/home/pi/programs/flask.py&quot;, line 1, in &lt;module&gt;</div><div class="line">    from flask import Flask</div><div class="line">ImportError: cannot import name Flask</div></pre></td></tr></table></figure></p>
<p>解决：让我对pyc有了稍微深的一点理解，我的python也不到家，需要补的东西太多，时间不够，继续努力吧。。。。。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Delete your local files that you named flask.py flask.pyc</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="6、需要配置一个可以让外网访问的端口号"><a href="#6、需要配置一个可以让外网访问的端口号" class="headerlink" title="6、需要配置一个可以让外网访问的端口号"></a>6、需要配置一个可以让外网访问的端口号</h3><p>(1)检查端口是否打开，以<code>8000</code>为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">telnet 127.0.0.1 8000</div></pre></td></tr></table></figure></p>
<p>(2)检查linux版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">lsb_release -a</div></pre></td></tr></table></figure></p>
<p>(3)确认debian版本添加开启端口号：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo iptables -A INPUT -p tcp --dport 8000 --jump ACCEPT</div><div class="line">iptables-save</div></pre></td></tr></table></figure></p>
<p>(4)隐藏执行python flask命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gunicorn router:app -p router.pid -b 0.0.0.0:8000 -D</div></pre></td></tr></table></figure></p>
<p>(5)取到pid，并kill应用进程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cd workspace</div><div class="line">cat router.pid</div><div class="line">kill `cat router.pid`</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;从此贴开始整理工作中遇到的奇怪需求和奇怪问题。。。。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1、同时出adhoc和appstore包&quot;&gt;&lt;a href=&quot;#1、同时出adhoc和appstore包&quot; class=&quot;headerlink&quot; title=&quot;1、同时出adhoc和ap
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(六)</title>
    <link href="http://yoursite.com/2016/10/18/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%85%AD/"/>
    <id>http://yoursite.com/2016/10/18/持续集成实施-六/</id>
    <published>2016-10-18T07:22:26.000Z</published>
    <updated>2016-12-07T00:41:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天遇到了一个非常变态的问题，所有涉及到操作缓存文件的都有提示<code>operation not permitted</code>。找了很多的解决方案，简单记述一下折腾的过程。</p>
<hr>
<h3 id="怀疑与bundler有关？"><a href="#怀疑与bundler有关？" class="headerlink" title="怀疑与bundler有关？"></a>怀疑与bundler有关？</h3><p>主要原因是之前出过很多次环境问题，都跟bundler有关，而且它是安装ruby包的必须插件，但是排查许久，也不能确定修改哪里可以解决，直到看到了一篇文章，说是因为需要修改<code>.bundle/config</code>，但是找不到这个目录作罢。</p>
<h3 id="确定是El-Capitan-加入了Rootless机制，设置-root-权限也不行。"><a href="#确定是El-Capitan-加入了Rootless机制，设置-root-权限也不行。" class="headerlink" title="确定是El Capitan 加入了Rootless机制，设置 root 权限也不行。"></a>确定是El Capitan 加入了Rootless机制，设置 root 权限也不行。</h3><p>于是尝试关闭 Rootless。重启按住 Command+R，进入恢复模式，打开Terminal。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">csrutil disable</div></pre></td></tr></table></figure></p>
<p>重启即可。如果要恢复默认，那么<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">csrutil enable</div></pre></td></tr></table></figure></p>
<h3 id="遇到新问题SSL-connect-returned-1-errno-0-state-SSLv3-read-server-certificate-B-certificate-verify-failed"><a href="#遇到新问题SSL-connect-returned-1-errno-0-state-SSLv3-read-server-certificate-B-certificate-verify-failed" class="headerlink" title="遇到新问题SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed"></a>遇到新问题<code>SSL_connect returned=1 errno=0 state=SSLv3 read server certificate B: certificate verify failed</code></h3><p>解决：简单讲升级ruby即可<br>1、安装rvm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">echo &quot;ruby_url=https://cache.ruby-china.org/pub/ruby&quot; &gt; ~/.rvm/user/db</div><div class="line">curl -L https://get.rvm.io | bash -s stable</div><div class="line">source ~/.rvm/scripts/rvm</div></pre></td></tr></table></figure></p>
<p>2、安装ruby<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm install 2.3.1 --disable-binary</div></pre></td></tr></table></figure></p>
<p>3、安装bundler升级gem<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gem install bundler -v 1.13.4</div><div class="line">sudo gem update --system</div></pre></td></tr></table></figure></p>
<p>4、安装fastlane<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo gem install fastlane</div></pre></td></tr></table></figure></p>
<p>5、默认ruby版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rvm 2.2.1 --default</div></pre></td></tr></table></figure></p>
<h3 id="总结一下遇到问题不能慌，慌也没用。。。。"><a href="#总结一下遇到问题不能慌，慌也没用。。。。" class="headerlink" title="总结一下遇到问题不能慌，慌也没用。。。。"></a>总结一下遇到问题不能慌，慌也没用。。。。</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天遇到了一个非常变态的问题，所有涉及到操作缓存文件的都有提示&lt;code&gt;operation not permitted&lt;/code&gt;。找了很多的解决方案，简单记述一下折腾的过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;怀疑与bundler有关？&quot;&gt;&lt;a href=&quot;#怀疑与b
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(五)</title>
    <link href="http://yoursite.com/2016/10/10/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%BA%94/"/>
    <id>http://yoursite.com/2016/10/10/持续集成实施-五/</id>
    <published>2016-10-10T09:14:43.000Z</published>
    <updated>2016-10-10T09:24:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>最初的需求是持续集成inhouse推送考虑例外情况（周六周日对比commit 若无更新，不进行推送）<br>通过经理指点，明白了需求是使用Jenkins时，如果GIT_COMMIT无变化，跳过构建<br>使用插件：<code>conditional steps(multiple)</code><br>github： <a href="https://github.com/jenkinsci/conditional-buildstep-plugin" target="_blank" rel="external">https://github.com/jenkinsci/conditional-buildstep-plugin</a><br>方法很简单：<br>如果环境变量GIT_PREVIOUS_SUCCESSFUL_COMMIT不存在，或者GIT_COMMIT和GIT_PREVIOUS_SUCCESSFUL_COMMIT不同，才会执行构建。<br>如下图所示：</p>
<hr>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/conditional.png" alt="Conditional配置"><br>还是检讨一下，考虑太少，对jenkins了解依然不够。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最初的需求是持续集成inhouse推送考虑例外情况（周六周日对比commit 若无更新，不进行推送）&lt;br&gt;通过经理指点，明白了需求是使用Jenkins时，如果GIT_COMMIT无变化，跳过构建&lt;br&gt;使用插件：&lt;code&gt;conditional steps(multip
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(四)</title>
    <link href="http://yoursite.com/2016/10/09/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E5%9B%9B/"/>
    <id>http://yoursite.com/2016/10/09/持续集成实施-四/</id>
    <published>2016-10-09T05:49:16.000Z</published>
    <updated>2016-10-10T03:51:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇介绍有关jenkins项目依赖的插件parameterized trigger plugin等。<br>先表明我们的需求是需要使用git parameter，这个插件的好处是可以在参数化构建前，将项目所<br>有分支同步过来然后选择分支构建，方便进行版本控制。</p>
<hr>
<h3 id="一、git-parameter使用"><a href="#一、git-parameter使用" class="headerlink" title="一、git parameter使用"></a>一、git parameter使用</h3><p>git parameter在github上地址：<a href="https://github.com/jenkinsci/git-parameter-plugin" target="_blank" rel="external">https://github.com/jenkinsci/git-parameter-plugin</a><br>在jenkins上安装插件以后，选择参数化构建就可以使用。<br>需要注意的是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1、Parameter Type==》Branch 或者 Tag等，目前使用Branch</div><div class="line">2、Branch Fiter==》正则匹配，可以过滤掉不希望显示的分支，</div><div class="line">3、目前为了过滤sandbox，使用表达式^((?!(sandbox)).)*$</div></pre></td></tr></table></figure></p>
<p>在使用git parameter之后，遇到了一个坑，因为在打iOS的包的时候，使用了Multiple SCMs来<br>拉取代码的，发现在使用过程中遇到，选择Build with Parameters时候，Branch出现报错提示为：<br><code>!No Git respository configured in SCM configuration</code>，原来git parameter这个插件不能支持Multiple SCMs，已经提了issue，开源作者貌似没动静。</p>
<h3 id="二、parameterized-trigger-plugin使用"><a href="#二、parameterized-trigger-plugin使用" class="headerlink" title="二、parameterized trigger plugin使用"></a>二、parameterized trigger plugin使用</h3><p>parameterized trigger plugin可以用来传递不同job一个文件名或者路径，这个时候我们不需要传递文件实体，那这个路径如何传递呢？比如有如下两个项目，我想把A的工作目录传递给B，让B使用。 操作流程分为两步：<br>1、在Ajob内的操作：</p>
<hr>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/parameterA.png" alt="A项目中配置"><br>如图所示：我将A项目的工作目录传递给了自定义参数TEST_WORKSPACE.到这里A项目的配置就完成了。<br>2、在Bjob内配置：</p>
<hr>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/parameterB.png" alt="B项目中配置"><br>我们在A项目配置的TEST_WORKSPACE参数，如果在B job中使用，首先我们在配置界面中，勾选The build is parameterized。这样我们就在当前工作环境中得到了由A传递过来的参数。</p>
<h3 id="三、Multijob-Plugin插件"><a href="#三、Multijob-Plugin插件" class="headerlink" title="三、Multijob Plugin插件"></a>三、Multijob Plugin插件</h3><p>这是一个集成了ParameterizedTrigger和BuildPipeline的插件，但它是形成一个新的job，而不是一个视图。并且它不要求job之间本身就存在依赖关系。这样一来，建立job的时候可以保持相对的独立性，而通过这个插件来组装成产品所需要的持续集成环境。<br>需要注意的是：在创建job时一定要选择“MultiJob Project”，在“free-style project”下默认<br>是不能选择使用这个插件的。<br>如图所示我集成了Multijob之后，新建了两个下游项目。</p>
<hr>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/Mutijob1.png" alt="Multijob展示"><br>配置如下：</p>
<hr>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/Mutijob2.png" alt="Multijob配置两个job"></p>
<p>需要在两个下游job中配置一下参数，就能引用Multijob中的参数：</p>
<hr>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/Mutijob3.png" alt="job配置两个job"></p>
<h3 id="四、Join-Plugin插件"><a href="#四、Join-Plugin插件" class="headerlink" title="四、Join Plugin插件"></a>四、Join Plugin插件</h3><p>这也是一个触发job的插件，亮点在于它触发job的条件是等待所有当前job的下游的job都完成才会发生。当然，只有在当前job有两个及以上的下游job时才有意义。简单举个例子来说，A同时触发B1和B2两个job，然后配置这个插件又触发C，这时C就会等B1和B2都完成之后才会被执行。<br>需要注意的是：默认情况下，通过Join插件触发的job是不能传递参数的，如果有需要，可以勾选“Trigger parameterized build on other project”，这样其实就是把Join插件和<br>ParameterizedTrigger插件集成起来了。</p>
<hr>
<p><img src="https://raw.githubusercontent.com/diaojunxian/diaojunxian.github.io/master/images/join1.png" alt="Join配置job"><br>当然同样需要在下游job中配置一下参数化构建，才能引用Join中的传递的参数。</p>
<h3 id="五、命令行直接git-clone代码"><a href="#五、命令行直接git-clone代码" class="headerlink" title="五、命令行直接git clone代码"></a>五、命令行直接git clone代码</h3><p>最后发现，这些插件都不能满足项目要求，最后无奈只能选用命令行git clone代码的方法，可以通过ssh(key file)或者https(.netrc)，当然我们的项目代码都是ssh，所以直接git clone ssh://xxx即可，当然，<br>需要在构建环境中选择SSH Agent确认Credentials。</p>
<hr>
<p>简单记述，以便整理。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇介绍有关jenkins项目依赖的插件parameterized trigger plugin等。&lt;br&gt;先表明我们的需求是需要使用git parameter，这个插件的好处是可以在参数化构建前，将项目所&lt;br&gt;有分支同步过来然后选择分支构建，方便进行版本控制。&lt;/p&gt;

    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(三)</title>
    <link href="http://yoursite.com/2016/10/08/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%B8%89/"/>
    <id>http://yoursite.com/2016/10/08/持续集成实施-三/</id>
    <published>2016-10-08T07:33:09.000Z</published>
    <updated>2016-10-10T03:26:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>持续集成到今天，回头望去满眼都是坑，简单梳理一下。。。。</p>
<hr>
<h3 id="一、iOS问题"><a href="#一、iOS问题" class="headerlink" title="一、iOS问题"></a>一、iOS问题</h3><p>1、因为两个平台用的xcode版本不一致，需要升级到xcode8，然后xcode打包有个大坑，需要将自动管理改为手动管理证书。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;&apos; &apos;s/ProvisioningStyle = Automatic;/ProvisioningStyle = Manual;/g&apos; </div><div class="line">&quot;$project_path/project.pbxproj&quot;</div></pre></td></tr></table></figure></p>
<p>2、xcode8打包多了个<code>PROVISIONING_PROFILE_SPECIFIER</code>需要指定证书具体名称。<br>最后用gym打包成功：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">DEVELOPER_DIR=&quot;/Applications/Xcode8.app&quot; </div><div class="line">PROVISIONING_PROFILE_SPECIFIER=&quot;$&#123;PROVISIONING_PROFILE_SPECIFIER&#125;&quot; </div><div class="line">gym </div><div class="line">--workspace $&#123;workspace_path&#125; --scheme $&#123;scheme&#125; --clean </div><div class="line">--configuration $&#123;configuration&#125; </div><div class="line">--xcargs&quot;PRODUCT_BUNDLE_IDENTIFIER=&apos;$&#123;bundle_id&#125;&apos; </div><div class="line">PROVISIONING_PROFILE=&apos;$&#123;rightProvision&#125;&apos; </div><div class="line">DEVELOPMENT_TEAM=&apos;$&#123;DEVELOPMENT_TEAM&#125;&apos;&quot; </div><div class="line">--export_method $&#123;export_method&#125; </div><div class="line">--archive_path $&#123;archive_path&#125;</div><div class="line">--codesigning_identity &quot;$&#123;rightDistributionSign&#125;&quot; </div><div class="line">--export_options $&#123;ExoptionPlist&#125; </div><div class="line">--output_directory $&#123;ipa_path&#125; </div><div class="line">--output_name $&#123;ipa_name&#125;</div></pre></td></tr></table></figure></p>
<p>3、pod install总是出现问题，分析可能是因为网络或者本机pod安装有问题。<br>若是pod问题，可以通过升级gem解决。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo gem update --system</div><div class="line">sudo gem install -n /usr/local/bin cocoapods</div></pre></td></tr></table></figure></p>
<p>4、很奇特命令行总是提示warning:Insecure would writable dir /usr/local/bin in path:mode 04077。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo chmod go -w /usr/local/bin</div></pre></td></tr></table></figure></p>
<hr>
<h3 id="二、安卓问题"><a href="#二、安卓问题" class="headerlink" title="二、安卓问题"></a>二、安卓问题</h3><p>1、在集成monkey执行过程中，出现增加下游项目，但是在上游项目执行完之后，下游项目却不执行的奇怪问题，使用插件<code>Build Other Project</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">配置configure build authorization==&gt;Run as who triggered Build</div><div class="line">设置Build after other project are built==&gt;在构建不稳定时依然触发</div><div class="line">配置Copy artifacts from another project，需要注意的是上一个项目一定要archive the </div><div class="line">artifacts</div><div class="line">通过解压tar -zxf /archive.tgz -C out/</div><div class="line">adb install -r out/*.apk</div></pre></td></tr></table></figure></p>
<p>还有iOS两个平台证书合并之后的问题待我解决。。。。。希望可以梳理一下苹果的证书的各种问题，等我足够了解吧。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;持续集成到今天，回头望去满眼都是坑，简单梳理一下。。。。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、iOS问题&quot;&gt;&lt;a href=&quot;#一、iOS问题&quot; class=&quot;headerlink&quot; title=&quot;一、iOS问题&quot;&gt;&lt;/a&gt;一、iOS问题&lt;/h3&gt;&lt;p&gt;1、因为两个平台用
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(二)</title>
    <link href="http://yoursite.com/2016/09/27/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%BA%8C/"/>
    <id>http://yoursite.com/2016/09/27/持续集成实施-二/</id>
    <published>2016-09-27T05:39:16.000Z</published>
    <updated>2016-09-27T06:41:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>此文，接持续集成一的内容，今天主要简单梳理android打包的<code>gradle</code>命令，和记述jenkins集成过程中遇到的问题和解决方案。</p>
<hr>
<h4 id="一、gradlew命令"><a href="#一、gradlew命令" class="headerlink" title="一、gradlew命令"></a>一、gradlew命令</h4><p>在iOS持续集成过程中，打包最后用fastlane方案解决，在android打包过程中，发现之前的方式是<br><code>gradle</code>，神奇的是fastlane也简介了<code>gradle</code>，关键点是之前打包提示报错<code>gradle</code>的版本较低，但是后来选择<code>gradlew</code>却能执行了。<br>gradlew 是什么东西呢，和gradle貌似不大一样，肯定有关系。没错，他就是gradle wrapper，意思是gradle的一个包装，大家可以理解为在这个项目本地就封装了gradle，比如我的项目是HelloWord, 在HelloWord/gradle/wrapper/gralde-wrapper.properties文件中声明了它指向的目录和版本，<br>比如工程的内容是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">distributionBase=GRADLE_USER_HOME</div><div class="line">distributionPath=wrapper/dists</div><div class="line">zipStoreBase=GRADLE_USER_HOME</div><div class="line">zipStorePath=wrapper/dists</div><div class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-2.10-all.zip</div></pre></td></tr></table></figure></p>
<p>如果你项目没有该文件的话，那么gradlew会到~/.gradle/wrapper/dists/gradle-2.10-all下寻找，或者你新建给文件，内容复制到里面。其实你会发现是同一个目录咯。里面会有个随机数的文件夹，里面就是gradle，只要下载成功即可用grdlew wrapper的命令代替全局的gradle命令。<br>这就是在jenkins执行过程中选择<code>Use Gradle Wrapper</code>的魅力之处了把。</p>
<h4 id="二、遇到的问题和整理"><a href="#二、遇到的问题和整理" class="headerlink" title="二、遇到的问题和整理"></a>二、遇到的问题和整理</h4><p>1、升级gym中提示报错<code>While executing gem(Gem:specific Gem Not Found Exception)</code><br>解决：很奇怪的解决方案<code>sudo gem update gym -v 0.10.0</code>就是之前升级命令指向了升级的版本号。</p>
<p>2、jenkins在一个project中使用多个repo的内容。譬如在打包task中支持ci_android的项目代码。 简单来说就是可以在一个job中clone下多份源码然后一一进行操作。<br>解决：其实这里需要做反省，之前对jenkins研究不是很透，然后还信誓旦旦的说了错话，感觉自己打脸自己，好响。闲话不表，其实jenkins中一个插件可以实现，<code>Multiple SCMs</code>可以实现，非常简单，<br>最重要的是可以在增加git源码的下面，有个选项<br><code>Additional Behaviours==&gt;check out to a sub-directory</code>可以新建一个子目录存放第<br>二个git下的源码。</p>
<hr>
<p>下面会继续研究lint已经各种静态代码检查的内容，并且继续踏坑。。。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此文，接持续集成一的内容，今天主要简单梳理android打包的&lt;code&gt;gradle&lt;/code&gt;命令，和记述jenkins集成过程中遇到的问题和解决方案。&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;一、gradlew命令&quot;&gt;&lt;a href=&quot;#一、gradlew命令&quot; clas
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>持续集成实施(一)</title>
    <link href="http://yoursite.com/2016/09/23/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%AE%9E%E6%96%BD-%E4%B8%80/"/>
    <id>http://yoursite.com/2016/09/23/持续集成实施-一/</id>
    <published>2016-09-23T11:03:23.000Z</published>
    <updated>2016-09-27T06:08:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>其实在前期已经投入精力对持续集成进行部署，但是真正的困难不是部署应该走的方向，却是过程中发生的一个个的“坑”，如何对待这些拦路虎并跨过他们，记述一二。</p>
<hr>
<h3 id="一、iOS集成"><a href="#一、iOS集成" class="headerlink" title="一、iOS集成"></a>一、iOS集成</h3><p>之前使用gym打包为这次iOS的集成提供了方便之门，但是这次需要注意的是:<br>1、需要分别打inhouse，adhoc，appstore的包<br>2、inhouse和adhoc作为内测，需要更换显示图标，加上内测字样。<br>3、inhouse包需要上传蒲公英（之前选择的Fir因为收费放弃），需要跟slack对接，并且自动推送。<br>4、appstore需要上传TestFlight<br>当然已经全部实现了，把其中遇到的波折一项项列一下。</p>
<hr>
<p>（1）分别打三种包，对证书和<code>rightProvision</code>了解的不够透彻？<br>解决：把三种证书都从开发那里要过来，然后将自己的APPLE ID升级到开发者<code>Admin</code>状态，就具有了三种证书的使用权限，然后跟开发一一对接，对每个包分别对应的证书了解并整理，打包的时候一一对应上就好。这个过程中，收获的是对xcodebuild的method参数有更深的了解，其实inhouse，adhoce，appstore分别对应的打包方式是<code>enterprise</code>，<code>ad-hoc</code>，<code>app-store</code>。<br>（2）需要更换inhouse的图标？<br>解决：之前想通过是打包的时候指向不同的<code>target</code>，后来的解决方案是直接替换。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">for file in os.listdir(appIconPath):</div><div class="line">    if &quot;.png&quot; in file:</div><div class="line">        for appicon in os.listdir(replaceAppIconPath):</div><div class="line">            if file == appicon:</div><div class="line">                shutil.copy(replaceAppIconPath+&apos;/&apos;+appicon, appIconPath+&apos;/&apos;+file)</div></pre></td></tr></table></figure></p>
<p>但是需要注意的是像素和尺寸需要保持一致，设计同学的帮忙很必要。<br>（3）之前上传Fir，后来因为Fir每日超过下载量需要收费，决定更改内测分发平台。<br>解决：之前是想通过上传公司内部服务器，然后给出外网链接，然后分发下载，后来因为感觉进入到下载页面以后没有关于ipa各种信息的介绍，比如build_version和build_number等。<br>但是要记录一下用ftp上传的时候由于是匿名上传，之前尝试出现各种错误，因为能力不够经验缺少的原因吧，后来用python实现上传ftp。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">def ftpconnect(host):</div><div class="line">    ftp = FTP()</div><div class="line">    ftp.connect(host, 21)  </div><div class="line">    # 登录</div><div class="line">    try:</div><div class="line">        ftp.login()</div><div class="line">    except ftplib.error_perm:</div><div class="line">        print &quot;ERROR: cannot login anonymously&quot;</div><div class="line">        ftp.quit()</div><div class="line">        return None</div><div class="line">    ftp.cwd(&apos;xx/&apos;) # *不是根目录*</div><div class="line">    return ftp</div><div class="line">def uploadfile(ftp, name, localpath):</div><div class="line">    bufsize = 1024</div><div class="line">    fp = open(localpath, &apos;rb&apos;)</div><div class="line">    ftp.storbinary(&apos;STOR &apos; + name, fp, bufsize)</div><div class="line">    ftp.set_debuglevel(0)</div><div class="line">    fp.close()</div><div class="line">if __name__ == &quot;__main__&quot;:</div><div class="line"></div><div class="line">    host = &quot;ip&quot;</div><div class="line">    localpath = &quot;xx&quot;</div><div class="line">    ipa_path = &quot;xx&quot;</div><div class="line">    name = &quot;xx.ipa&quot;</div><div class="line">    ftp = ftpconnect(host)</div><div class="line">    uploadfile(ftp, name, localpath)</div><div class="line">    ftp.quit()</div></pre></td></tr></table></figure></p>
<p>其实之前放弃蒲公英是因为蒲公英上传之后的api返回值有一个特点，生成的二维码是固定不变的，但是下载的短链接网址是跟着其中的key字段改变的，经过仔细对比发现<code>appShortcutUrl</code>字段不会变化。自然有了对策。实现方式，自己拼接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def parseUploadResult(jsonResult):</div><div class="line">    resultCode = jsonResult[&apos;code&apos;]</div><div class="line">    if resultCode != 0:</div><div class="line">        print &quot;Upload Fail!&quot;</div><div class="line">        raise Exception(&quot;Reason: %s&quot; % jsonResult[&apos;message&apos;])</div><div class="line">    appShortcutUrl = jsonResult[&apos;data&apos;][&apos;appShortcutUrl&apos;]</div><div class="line">    appDownloadPageURL = &quot;https://www.pgyer.com/%s&quot; % appShortcutUrl</div><div class="line">    return appDownloadPageURL</div></pre></td></tr></table></figure></p>
<p>（4）和slack对接<br>解决：其实我觉得slack真的非常好用，因为它提供了各种整合持续集成的api，这里特别佩服我们老大对这块内容的重视，slack和jenkins集成非常方便。只是网速有点不靠谱。<br>slack api地址:<code>https://api.slack.com/docs/message-guidelines</code><br>然后构造请求，发送即可，详细不表。<br>（5）将appstore的包上传TestFlight<br>解决：之前安装testflight，一直遇到的问题是会有一个类似如下的报错：<br><code>from /usr/local/bin/fastlane:23:in &#39;&lt;main&gt;&#39;</code>，其实一条命令解决了，<br><code>sudo gem uninstall bundler</code>，其实这是fastlane的bug。<br>用pilot可以上传到TestFlight，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">pilot upload --verbose --username $&#123;username&#125; </div><div class="line">--app_identifier $&#123;bundle_id&#125; --ipa $&#123;ipa_path&#125; --apple_id $&#123;apple_id&#125; </div><div class="line">--team_id $&#123;team_id&#125; --team_name &quot;$&#123;team_name&#125;&quot; --dev_portal_team_id </div><div class="line">$&#123;dev_portal_team_id&#125; --itc_provider &quot;$&#123;itc_provider&#125;&quot;</div></pre></td></tr></table></figure></p>
<h3 id="二、Android集成"><a href="#二、Android集成" class="headerlink" title="二、Android集成"></a>二、Android集成</h3><p>安卓打包更简单一点，但是一上来的错误就弄懵懂了我，因为对安卓平台的确接触不多。</p>
<hr>
<p>（1）gradle version is 2.14.1，Current Version is 2.9。<br>解决：最后很简单就实现，选择jenkins构建grale脚本中，Use Gradle Wrapper，即可。</p>
<hr>
<p>先写这么多，因为发现安卓又报错了，去解决问题了。。。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;其实在前期已经投入精力对持续集成进行部署，但是真正的困难不是部署应该走的方向，却是过程中发生的一个个的“坑”，如何对待这些拦路虎并跨过他们，记述一二。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;一、iOS集成&quot;&gt;&lt;a href=&quot;#一、iOS集成&quot; class=&quot;headerlin
    
    </summary>
    
    
  </entry>
  
</feed>
